{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/** @module WhatsAppAPI */\n\nimport {\n    ClientMessage,\n    type WhatsAppAPIConstructorArguments,\n    type PostData,\n    type GetParams,\n    type ClientMessageRequest,\n    type ClientTypingIndicators,\n    type ServerMessageResponse,\n    type ServerMarkAsReadResponse,\n    type ServerCreateQRResponse,\n    type ServerRetrieveQRResponse,\n    type ServerUpdateQRResponse,\n    type ServerDeleteQRResponse,\n    type ServerMediaRetrieveResponse,\n    type ServerMediaUploadResponse,\n    type ServerMediaDeleteResponse,\n    type ServerBlockResponse,\n    type ServerUnblockResponse,\n    type ServerPreacceptCallResponse,\n    type ServerAcceptCallResponse,\n    type ServerTerminateCallResponse,\n    type ServerRejectCallResponse,\n    type ServerInitiateCallResponse\n} from \"./types.js\";\nimport type {\n    OnCallConnect,\n    OnCallConnectArgs,\n    OnCallStatus,\n    OnCallStatusArgs,\n    OnCallTerminate,\n    OnCallTerminateArgs,\n    OnMessage,\n    OnMessageArgs,\n    OnSent,\n    OnSentArgs,\n    OnStatus,\n    OnStatusArgs\n} from \"./emitters.d.ts\";\n\nimport * as Cloud from \"./apis/index.js\";\n\nimport { escapeUnicode, MaybePromise } from \"./utils.js\";\nimport { DEFAULT_API_VERSION } from \"./types.js\";\nimport {\n    WhatsAppAPIMissingAppSecretError,\n    WhatsAppAPIMissingCryptoSubtleError,\n    WhatsAppAPIMissingRawBodyError,\n    WhatsAppAPIMissingSignatureError,\n    WhatsAppAPIMissingVerifyTokenError,\n    WhatsAppAPIUnexpectedError,\n    WhatsAppAPIFailedToVerifyError,\n    WhatsAppAPIMissingSearchParamsError,\n    WhatsAppAPIFailedToVerifyTokenError\n} from \"./errors.js\";\n\n/**\n * The main API Class\n *\n * @template EmittersReturnType - The return type of the emitters\n * ({@link OnMessage}, {@link OnStatus})\n */\nexport class WhatsAppAPI<EmittersReturnType = void>\n    implements\n        Cloud.Message.API,\n        Cloud.Call.API,\n        Cloud.QR.API,\n        Cloud.Media.API,\n        Cloud.Block.API,\n        Cloud.Webhook.API<EmittersReturnType>\n{\n    //#region Properties\n    /**\n     * The API token\n     */\n    private token: string;\n    /**\n     * The app secret\n     */\n    private appSecret?: string;\n    /**\n     * The webhook verify token\n     */\n    private webhookVerifyToken?: string;\n    /**\n     * The API version to use\n     */\n    private v: string;\n    /**\n     * The fetch function for the requests\n     */\n    private fetch: typeof fetch;\n    /**\n     * The CryptoSubtle library for checking the signatures\n     */\n    private subtle?: Pick<typeof crypto.subtle, \"importKey\" | \"sign\">;\n    /**\n     * If false, the API will be used in a less secure way, removing the need for appSecret. Defaults to true.\n     */\n    private secure: boolean;\n    /**\n     * The callbacks for the events (message, sent, status, call)\n     *\n     * @example\n     * ```ts\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"my-token\",\n     *     appSecret: \"my-app-secret\"\n     * });\n     *\n     * // Set the callback\n     * Whatsapp.on.message = ({ from, phoneID }) => console.log(`Message from ${from} to bot ${phoneID}`);\n     *\n     * // If you need to disable the callback:\n     * // Whatsapp.on.message = undefined;\n     * ```\n     */\n    public on: {\n        message?: OnMessage<EmittersReturnType>;\n        sent?: OnSent;\n        status?: OnStatus<EmittersReturnType>;\n        call: {\n            connect?: OnCallConnect<EmittersReturnType>;\n            terminate?: OnCallTerminate<EmittersReturnType>;\n            status?: OnCallStatus<EmittersReturnType>;\n        };\n    } = {\n        call: {}\n    };\n    //#endregion\n\n    /**\n     * Main entry point for the API.\n     *\n     * It's highly recommended reading the named parameters docs at\n     * {@link types.TheBasicConstructorArguments},\n     * at least for `token`, `appSecret` and `webhookVerifyToken` properties,\n     * which are the most common in normal usage.\n     *\n     * The other parameters are used for fine tunning the framework,\n     * such as `ponyfill`, which allows the code to execute on platforms\n     * that are missing standard APIs such as fetch and crypto.\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *    token: \"YOUR_TOKEN\",\n     *    appSecret: \"YOUR_APP_SECRET\"\n     * });\n     * ```\n     *\n     * @template EmittersReturnType - The return type of the emitters\n     * ({@link OnMessage}, {@link OnStatus})\n     *\n     * @throws If fetch is not defined in the enviroment and the provided ponyfill isn't a function\n     * @throws If secure is true, crypto.subtle is not defined in the enviroment and the provided ponyfill isn't an object\n     */\n    constructor({\n        token,\n        appSecret,\n        webhookVerifyToken,\n        v,\n        secure = true,\n        ponyfill = {}\n    }: WhatsAppAPIConstructorArguments) {\n        this.token = token;\n        this.secure = !!secure;\n\n        if (this.secure) {\n            this.appSecret = appSecret;\n\n            if (\n                typeof ponyfill.subtle !== \"object\" &&\n                (typeof crypto !== \"object\" ||\n                    typeof crypto?.subtle !== \"object\")\n            ) {\n                throw new Error(\n                    \"subtle is not defined in the enviroment. Consider using a setup helper,\" +\n                        \" defined at 'whatsapp-api-js/setup', or provide a valid ponyfill\" +\n                        \" object with the argument 'ponyfill.subtle'.\"\n                );\n            }\n\n            // Let's hope the user is using a valid ponyfill\n            this.subtle = ponyfill.subtle || crypto.subtle;\n        }\n\n        if (webhookVerifyToken) this.webhookVerifyToken = webhookVerifyToken;\n\n        if (\n            typeof ponyfill.fetch !== \"function\" &&\n            typeof fetch !== \"function\"\n        ) {\n            throw new Error(\n                \"fetch is not defined in the enviroment. Consider using a setup helper,\" +\n                    \" defined at 'whatsapp-api-js/setup', or provide a valid ponyfill\" +\n                    \" object with the argument 'ponyfill.fetch'.\"\n            );\n        }\n\n        // Let's hope the user is using a valid ponyfill\n        this.fetch = ponyfill.fetch || fetch;\n\n        if (v) this.v = v;\n        else {\n            console.warn(\n                `[whatsapp-api-js] Cloud API version not defined. In production, it's strongly recommended pinning it to the desired version with the \"v\" argument. Defaulting to \"${DEFAULT_API_VERSION}\".`\n            );\n            this.v = DEFAULT_API_VERSION;\n        }\n    }\n\n    //#region Message Operations\n\n    async sendMessage(\n        phoneID: string,\n        to: string,\n        message: ClientMessage,\n        context?: string,\n        biz_opaque_callback_data?: string\n    ) {\n        const type = message._type;\n\n        const request = {\n            messaging_product: \"whatsapp\",\n            type,\n            to\n        } as ClientMessageRequest;\n\n        request[type] = message;\n\n        if (context) request.context = { message_id: context };\n        if (biz_opaque_callback_data)\n            request.biz_opaque_callback_data = biz_opaque_callback_data;\n\n        // Make the post request\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(request)\n            }\n        );\n\n        const response = await this.getBody<ServerMessageResponse>(promise);\n        const has_msg = \"messages\" in response;\n\n        const args: OnSentArgs = {\n            phoneID,\n            to,\n            type,\n            message,\n            request,\n            id: has_msg ? response.messages[0].id : undefined,\n            held_for_quality_assessment: has_msg\n                ? \"message_status\" in response.messages[0]\n                    ? response.messages[0].message_status ===\n                      \"held_for_quality_assessment\"\n                    : undefined\n                : undefined,\n            response,\n            offload: WhatsAppAPI.offload,\n            Whatsapp: this\n        };\n\n        try {\n            await this.on?.sent?.(args);\n        } catch (error) {\n            // Eh... I don't like it nor hate it\n            console.error(error);\n        }\n\n        return response ?? promise;\n    }\n\n    broadcastMessage(\n        phoneID: string,\n        to: string[],\n        message: ClientMessage,\n        batch_size: number,\n        delay: number\n    ): Array<ReturnType<WhatsAppAPI[\"sendMessage\"]>>;\n\n    broadcastMessage<T>(\n        phoneID: string,\n        to: T[],\n        message_builder: (data: T) => [string, ClientMessage],\n        batch_size: number,\n        delay: number\n    ): Array<ReturnType<WhatsAppAPI[\"sendMessage\"]>>;\n\n    broadcastMessage<T>(\n        phoneID: string,\n        to: string[] | T[],\n        message_builder:\n            | ClientMessage\n            | ((data: T) => MaybePromise<[string, ClientMessage]>),\n        batch_size = 50,\n        delay = 1000\n    ) {\n        const responses = [] as ReturnType<WhatsAppAPI[\"sendMessage\"]>[];\n\n        if (batch_size < 1) {\n            throw new RangeError(\"batch_size must be greater than 0\");\n        }\n\n        if (delay < 0) {\n            throw new RangeError(\"delay must be greater or equal to 0\");\n        }\n\n        to.forEach((data, i) => {\n            responses.push(\n                new Promise((resolve) => {\n                    setTimeout(\n                        async () => {\n                            let phone: string;\n                            let message: ClientMessage;\n\n                            if (message_builder instanceof ClientMessage) {\n                                phone = data as string;\n                                message = message_builder;\n                            } else {\n                                [phone, message] = await message_builder(\n                                    data as T\n                                );\n                            }\n\n                            this.sendMessage(phoneID, phone, message).then(\n                                resolve\n                            );\n                        },\n                        delay * ((i / batch_size) | 0)\n                    );\n                })\n            );\n        });\n\n        return responses;\n    }\n\n    async markAsRead(\n        phoneID: string,\n        messageId: string,\n        indicator?: ClientTypingIndicators\n    ) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    status: \"read\",\n                    message_id: messageId,\n                    typing_indicator: indicator\n                        ? { type: indicator }\n                        : undefined\n                })\n            }\n        );\n\n        return this.getBody<ServerMarkAsReadResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region Call Operations\n\n    async initiateCall(\n        phoneID: string,\n        to: string,\n        sdp: string,\n        biz_opaque_callback_data?: string\n    ) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/calls`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    to,\n                    action: \"connect\",\n                    biz_opaque_callback_data,\n                    session: {\n                        sdp_type: \"offer\",\n                        sdp\n                    }\n                })\n            }\n        );\n\n        return this.getBody<ServerInitiateCallResponse>(promise);\n    }\n\n    async preacceptCall(\n        phoneID: string,\n        callID: `wacid.${string}`,\n        sdp: string\n    ) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/calls`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    call_id: callID,\n                    action: \"pre_accept\",\n                    session: {\n                        sdp_type: \"offer\",\n                        sdp\n                    }\n                })\n            }\n        );\n\n        return this.getBody<ServerPreacceptCallResponse>(promise);\n    }\n\n    async rejectCall(phoneID: string, callID: `wacid.${string}`) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/calls`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    call_id: callID,\n                    action: \"reject\"\n                })\n            }\n        );\n\n        return this.getBody<ServerRejectCallResponse>(promise);\n    }\n\n    async acceptCall(\n        phoneID: string,\n        callID: `wacid.${string}`,\n        sdp: string,\n        biz_opaque_callback_data?: string\n    ) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/calls`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    call_id: callID,\n                    action: \"accept\",\n                    biz_opaque_callback_data,\n                    session: {\n                        sdp_type: \"offer\",\n                        sdp\n                    }\n                })\n            }\n        );\n\n        return this.getBody<ServerAcceptCallResponse>(promise);\n    }\n\n    async terminateCall(phoneID: string, callID: `wacid.${string}`) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/calls`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    call_id: callID,\n                    action: \"terminate\"\n                })\n            }\n        );\n\n        return this.getBody<ServerTerminateCallResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region QR Operations\n\n    async createQR(\n        phoneID: string,\n        message: string,\n        format: \"png\" | \"svg\" = \"png\"\n    ) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls?generate_qr_image=${format}&prefilled_message=${message}`,\n            {\n                method: \"POST\"\n            }\n        );\n\n        return this.getBody<ServerCreateQRResponse>(promise);\n    }\n\n    async retrieveQR(phoneID: string, id?: string) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id ?? \"\"}`\n        );\n\n        return this.getBody<ServerRetrieveQRResponse>(promise);\n    }\n\n    async updateQR(phoneID: string, id: string, message: string) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}?prefilled_message=${message}`,\n            {\n                method: \"POST\"\n            }\n        );\n\n        return this.getBody<ServerUpdateQRResponse>(promise);\n    }\n\n    async deleteQR(phoneID: string, id: string) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}`,\n            {\n                method: \"DELETE\"\n            }\n        );\n\n        return this.getBody<ServerDeleteQRResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region Media Operations\n\n    async retrieveMedia(id: string, phoneID?: string) {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`\n        );\n\n        return this.getBody<ServerMediaRetrieveResponse>(promise);\n    }\n\n    async uploadMedia(phoneID: string, form: unknown, check = true) {\n        if (check) {\n            if (\n                !form ||\n                typeof form !== \"object\" ||\n                !(\"get\" in form) ||\n                typeof form.get !== \"function\"\n            )\n                throw new TypeError(\n                    \"File's Form must be an instance of FormData\"\n                );\n\n            const file = form.get(\"file\") as Blob;\n\n            if (!file.type)\n                throw new Error(\"File's Blob must have a type specified\");\n\n            const validMediaTypes = [\n                \"audio/aac\",\n                \"audio/mp4\",\n                \"audio/mpeg\",\n                \"audio/amr\",\n                \"audio/ogg\",\n                \"text/plain\",\n                \"application/pdf\",\n                \"application/vnd.ms-powerpoint\",\n                \"application/msword\",\n                \"application/vnd.ms-excel\",\n                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n                \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n                \"image/jpeg\",\n                \"image/png\",\n                \"video/mp4\",\n                \"video/3gp\",\n                \"image/webp\"\n            ];\n\n            if (!validMediaTypes.includes(file.type))\n                throw new Error(`Invalid media type: ${file.type}`);\n\n            const validMediaSizes = {\n                audio: 16_000_000,\n                text: 100_000_000,\n                application: 100_000_000,\n                image: 5_000_000,\n                video: 16_000_000,\n                sticker: 500_000\n            };\n\n            const mediaType =\n                file.type === \"image/webp\"\n                    ? \"sticker\"\n                    : (file.type.split(\"/\")[0] as keyof typeof validMediaSizes);\n\n            if (file.size && file.size > validMediaSizes[mediaType])\n                throw new Error(\n                    `File is too big (${file.size} bytes) for a ${mediaType} (${validMediaSizes[mediaType]} bytes limit)`\n                );\n        }\n\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/media?messaging_product=whatsapp`,\n            {\n                method: \"POST\",\n                body: form as FormData\n            }\n        );\n\n        return this.getBody<ServerMediaUploadResponse>(promise);\n    }\n\n    fetchMedia(url: string) {\n        /**\n         * Hacky way to check if the url is valid and throw if invalid\n         *\n         * @see https://github.com/Secreto31126/whatsapp-api-js/issues/335#issuecomment-2103814359\n         */\n        return this.$$apiFetch$$(new URL(url), {\n            headers: {\n                // Thanks @tecoad\n                \"User-Agent\":\n                    \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"\n            }\n        });\n    }\n\n    async deleteMedia(id: string, phoneID?: string) {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`,\n            {\n                method: \"DELETE\"\n            }\n        );\n\n        return this.getBody<ServerMediaDeleteResponse>(promise);\n    }\n\n    // #endregion\n\n    // #region Block Operations\n\n    async blockUser(phoneID: string, ...users: string[]) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/block_users`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    block_users: users.map((user) => ({ user }))\n                })\n            }\n        );\n\n        return this.getBody<ServerBlockResponse>(promise);\n    }\n\n    async unblockUser(phoneID: string, ...users: string[]) {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${phoneID}/block_users`,\n            {\n                method: \"DELETE\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    block_users: users.map((user) => ({ user }))\n                })\n            }\n        );\n\n        return this.getBody<ServerUnblockResponse>(promise);\n    }\n\n    // #endregion\n\n    // #region Webhooks\n\n    async post(\n        data: PostData,\n        raw_body: string,\n        signature: string\n    ): Promise<EmittersReturnType | undefined>;\n\n    async post(data: PostData): Promise<EmittersReturnType | undefined>;\n\n    async post(data: PostData, raw_body?: string, signature?: string) {\n        // Validating the payload\n        if (this.secure) {\n            if (!raw_body) throw new WhatsAppAPIMissingRawBodyError();\n            if (!signature) throw new WhatsAppAPIMissingSignatureError();\n\n            if (!(await this.verifyRequestSignature(raw_body, signature))) {\n                throw new WhatsAppAPIFailedToVerifyError();\n            }\n        }\n\n        // Throw \"400 Bad Request\" if data is not a valid WhatsApp API request\n        if (!data.object) {\n            throw new WhatsAppAPIUnexpectedError(\"Invalid payload\", 400);\n        }\n\n        const { field, value } = data.entry[0].changes[0];\n        const phoneID = value.metadata.phone_number_id;\n\n        // Check if the message is a message or a status update\n        if (field === \"messages\") {\n            if (field in value) {\n                const message = value.messages[0];\n\n                const contact = value.contacts?.[0];\n\n                const from = contact?.wa_id ?? message.from;\n                const name = contact?.profile.name;\n\n                const args: OnMessageArgs = {\n                    phoneID,\n                    from,\n                    message,\n                    name,\n                    raw: data,\n                    reply: (\n                        response,\n                        context = false,\n                        biz_opaque_callback_data\n                    ) =>\n                        this.sendMessage(\n                            phoneID,\n                            from,\n                            response,\n                            context ? message.id : undefined,\n                            biz_opaque_callback_data\n                        ),\n                    received: (i) => this.markAsRead(phoneID, message.id, i),\n                    block: () => this.blockUser(phoneID, from),\n                    offload: WhatsAppAPI.offload,\n                    Whatsapp: this\n                };\n\n                return this.on?.message?.(args);\n            } else if (\"statuses\" in value) {\n                const statuses = value.statuses[0];\n\n                const phone = statuses.recipient_id;\n                const status = statuses.status;\n                const id = statuses.id;\n                const timestamp = statuses.timestamp;\n                const conversation = statuses.conversation;\n                const pricing = statuses.pricing;\n                const error = statuses.errors?.[0];\n                const biz_opaque_callback_data =\n                    statuses.biz_opaque_callback_data;\n\n                const args: OnStatusArgs = {\n                    phoneID,\n                    phone,\n                    status,\n                    id,\n                    timestamp,\n                    conversation,\n                    pricing,\n                    error,\n                    biz_opaque_callback_data,\n                    raw: data,\n                    offload: WhatsAppAPI.offload,\n                    Whatsapp: this\n                };\n\n                return this.on?.status?.(args);\n            }\n        } else if (field === \"calls\") {\n            if (field in value) {\n                const call = value.calls[0];\n\n                const contact = value.contacts?.[0];\n\n                const from = contact?.wa_id ?? call.from;\n                const name = contact?.profile.name;\n\n                if (call.event === \"connect\") {\n                    const args: OnCallConnectArgs = {\n                        phoneID,\n                        from,\n                        call,\n                        name,\n                        raw: data,\n                        preaccept: () =>\n                            this.preacceptCall(\n                                phoneID,\n                                call.id,\n                                call.session.sdp\n                            ),\n                        accept: (biz_opaque_callback_data) =>\n                            this.acceptCall(\n                                phoneID,\n                                call.id,\n                                call.session.sdp,\n                                biz_opaque_callback_data\n                            ),\n                        reject: () => this.rejectCall(phoneID, call.id),\n                        terminate: () => this.terminateCall(phoneID, call.id),\n                        offload: WhatsAppAPI.offload,\n                        Whatsapp: this\n                    };\n\n                    return this.on?.call?.connect?.(args);\n                } else if (call.event === \"terminate\") {\n                    const args: OnCallTerminateArgs = {\n                        phoneID,\n                        from,\n                        call,\n                        name,\n                        raw: data,\n                        offload: WhatsAppAPI.offload,\n                        Whatsapp: this\n                    };\n\n                    return this.on?.call?.terminate?.(args);\n                }\n            } else if (\"statuses\" in value) {\n                const statuses = value.statuses[0];\n\n                const phone = statuses.recipient_id;\n                const status = statuses.status;\n                const id = statuses.id;\n                const timestamp = statuses.timestamp;\n                const biz_opaque_callback_data =\n                    statuses.biz_opaque_callback_data;\n\n                const args: OnCallStatusArgs = {\n                    phoneID,\n                    phone,\n                    status,\n                    id,\n                    timestamp,\n                    biz_opaque_callback_data,\n                    raw: data,\n                    offload: WhatsAppAPI.offload,\n                    Whatsapp: this\n                };\n\n                return this.on?.call?.status?.(args);\n            }\n        }\n\n        // If unknown payload, just ignore it\n        // Facebook doesn't care about your server's opinion\n        throw new WhatsAppAPIUnexpectedError(\"Unexpected payload\", 200);\n    }\n\n    get(params: GetParams) {\n        if (!this.webhookVerifyToken) {\n            throw new WhatsAppAPIMissingVerifyTokenError();\n        }\n\n        // Parse params from the webhook verification request\n        const {\n            \"hub.mode\": mode,\n            \"hub.verify_token\": token,\n            \"hub.challenge\": challenge\n        } = params;\n\n        // Check if a token and mode were sent\n        if (!mode || !token) {\n            throw new WhatsAppAPIMissingSearchParamsError();\n        }\n\n        // Check the mode and token sent are correct\n        if (mode === \"subscribe\" && token === this.webhookVerifyToken) {\n            return challenge;\n        }\n\n        // Responds with \"403 Forbidden\" if verify tokens do not match\n        throw new WhatsAppAPIFailedToVerifyTokenError();\n    }\n\n    // #endregion\n\n    /**\n     * Make an authenticated request to any url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * It's strongly recommended NOT using this method as you might risk exposing your API key accidentally,\n     * but it's here in case you need a specific API operation which is not implemented by the library.\n     *\n     * @param url - The url to fetch\n     * @param options - The fetch options (headers.Authorization is already included)\n     * @returns The fetch response\n     */\n    async $$apiFetch$$(\n        url: string | URL | Request,\n        options: RequestInit = {}\n    ): Promise<Response> {\n        return this.fetch(url, {\n            ...options,\n            headers: {\n                Authorization: `Bearer ${this.token}`,\n                ...options.headers\n            }\n        });\n    }\n\n    /**\n     * Verify the signature of a request\n     *\n     * @param raw_body - The raw body of the request\n     * @param signature - The signature to validate\n     * @returns If the signature is valid\n     * @throws Class {@link WhatsAppAPIMissingAppSecretError} if the appSecret isn't defined\n     * @throws Class {@link WhatsAppAPIMissingCryptoSubtleError} if crypto.subtle or ponyfill isn't available\n     */\n    async verifyRequestSignature(\n        raw_body: string,\n        signature: string\n    ): Promise<boolean> {\n        if (!this.appSecret) throw new WhatsAppAPIMissingAppSecretError();\n        if (!this.subtle) throw new WhatsAppAPIMissingCryptoSubtleError();\n\n        signature = signature.split(\"sha256=\")[1];\n        if (!signature) return false;\n\n        const encoder = new TextEncoder();\n        const keyBuffer = encoder.encode(this.appSecret);\n\n        const key = await this.subtle.importKey(\n            \"raw\",\n            keyBuffer,\n            { name: \"HMAC\", hash: \"SHA-256\" },\n            true,\n            [\"sign\", \"verify\"]\n        );\n\n        const data = encoder.encode(escapeUnicode(raw_body));\n        const result = await this.subtle.sign(\"HMAC\", key, data);\n        const result_array = Array.from(new Uint8Array(result));\n\n        // Convert an array of bytes to a hex string\n        const check = result_array\n            .map((b) => b.toString(16).padStart(2, \"0\"))\n            .join(\"\");\n\n        return signature === check;\n    }\n\n    /**\n     * Get the body of a fetch response\n     *\n     * @internal\n     * @param promise - The fetch response\n     * @returns The json body parsed\n     */\n    private async getBody<T>(promise: Promise<Response>): Promise<T> {\n        return (await promise).json();\n    }\n\n    /**\n     * Offload a function to the next tick of the event loop\n     *\n     * @param f - The function to offload from the main thread\n     */\n    static offload(f: () => unknown) {\n        // Thanks @RahulLanjewar93\n        Promise.resolve().then(f);\n    }\n}\n"],
  "mappings": "AAEA;AAAA,EACI;AAAA,OAsBG;AAkBP,SAAS,qBAAmC;AAC5C,SAAS,2BAA2B;AACpC;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACG;AAQA,MAAM,YAQb;AAAA;AAAA;AAAA;AAAA;AAAA,EAKY;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA,EAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBD,KASH;AAAA,IACA,MAAM,CAAC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BA,YAAY;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,WAAW,CAAC;AAAA,EAChB,GAAoC;AAChC,SAAK,QAAQ;AACb,SAAK,SAAS,CAAC,CAAC;AAEhB,QAAI,KAAK,QAAQ;AACb,WAAK,YAAY;AAEjB,UACI,OAAO,SAAS,WAAW,aAC1B,OAAO,WAAW,YACf,OAAO,QAAQ,WAAW,WAChC;AACE,cAAM,IAAI;AAAA,UACN;AAAA,QAGJ;AAAA,MACJ;AAGA,WAAK,SAAS,SAAS,UAAU,OAAO;AAAA,IAC5C;AAEA,QAAI,mBAAoB,MAAK,qBAAqB;AAElD,QACI,OAAO,SAAS,UAAU,cAC1B,OAAO,UAAU,YACnB;AACE,YAAM,IAAI;AAAA,QACN;AAAA,MAGJ;AAAA,IACJ;AAGA,SAAK,QAAQ,SAAS,SAAS;AAE/B,QAAI,EAAG,MAAK,IAAI;AAAA,SACX;AACD,cAAQ;AAAA,QACJ,qKAAqK,mBAAmB;AAAA,MAC5L;AACA,WAAK,IAAI;AAAA,IACb;AAAA,EACJ;AAAA;AAAA,EAIA,MAAM,YACF,SACA,IACA,SACA,SACA,0BACF;AACE,UAAM,OAAO,QAAQ;AAErB,UAAM,UAAU;AAAA,MACZ,mBAAmB;AAAA,MACnB;AAAA,MACA;AAAA,IACJ;AAEA,YAAQ,IAAI,IAAI;AAEhB,QAAI,QAAS,SAAQ,UAAU,EAAE,YAAY,QAAQ;AACrD,QAAI;AACA,cAAQ,2BAA2B;AAGvC,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO;AAAA,MAC/C;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU,OAAO;AAAA,MAChC;AAAA,IACJ;AAEA,UAAM,WAAW,MAAM,KAAK,QAA+B,OAAO;AAClE,UAAM,UAAU,cAAc;AAE9B,UAAM,OAAmB;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,IAAI,UAAU,SAAS,SAAS,CAAC,EAAE,KAAK;AAAA,MACxC,6BAA6B,UACvB,oBAAoB,SAAS,SAAS,CAAC,IACnC,SAAS,SAAS,CAAC,EAAE,mBACrB,gCACA,SACJ;AAAA,MACN;AAAA,MACA,SAAS,YAAY;AAAA,MACrB,UAAU;AAAA,IACd;AAEA,QAAI;AACA,YAAM,KAAK,IAAI,OAAO,IAAI;AAAA,IAC9B,SAAS,OAAO;AAEZ,cAAQ,MAAM,KAAK;AAAA,IACvB;AAEA,WAAO,YAAY;AAAA,EACvB;AAAA,EAkBA,iBACI,SACA,IACA,iBAGA,aAAa,IACb,QAAQ,KACV;AACE,UAAM,YAAY,CAAC;AAEnB,QAAI,aAAa,GAAG;AAChB,YAAM,IAAI,WAAW,mCAAmC;AAAA,IAC5D;AAEA,QAAI,QAAQ,GAAG;AACX,YAAM,IAAI,WAAW,qCAAqC;AAAA,IAC9D;AAEA,OAAG,QAAQ,CAAC,MAAM,MAAM;AACpB,gBAAU;AAAA,QACN,IAAI,QAAQ,CAAC,YAAY;AACrB;AAAA,YACI,YAAY;AACR,kBAAI;AACJ,kBAAI;AAEJ,kBAAI,2BAA2B,eAAe;AAC1C,wBAAQ;AACR,0BAAU;AAAA,cACd,OAAO;AACH,iBAAC,OAAO,OAAO,IAAI,MAAM;AAAA,kBACrB;AAAA,gBACJ;AAAA,cACJ;AAEA,mBAAK,YAAY,SAAS,OAAO,OAAO,EAAE;AAAA,gBACtC;AAAA,cACJ;AAAA,YACJ;AAAA,YACA,SAAU,IAAI,aAAc;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,WACF,SACA,WACA,WACF;AACE,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO;AAAA,MAC/C;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,QAAQ;AAAA,UACR,YAAY;AAAA,UACZ,kBAAkB,YACZ,EAAE,MAAM,UAAU,IAClB;AAAA,QACV,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAAkC,OAAO;AAAA,EACzD;AAAA;AAAA;AAAA,EAMA,MAAM,aACF,SACA,IACA,KACA,0BACF;AACE,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB;AAAA,UACA,QAAQ;AAAA,UACR;AAAA,UACA,SAAS;AAAA,YACL,UAAU;AAAA,YACV;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAAoC,OAAO;AAAA,EAC3D;AAAA,EAEA,MAAM,cACF,SACA,QACA,KACF;AACE,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,SAAS;AAAA,YACL,UAAU;AAAA,YACV;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAAqC,OAAO;AAAA,EAC5D;AAAA,EAEA,MAAM,WAAW,SAAiB,QAA2B;AACzD,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,SAAS;AAAA,UACT,QAAQ;AAAA,QACZ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAAkC,OAAO;AAAA,EACzD;AAAA,EAEA,MAAM,WACF,SACA,QACA,KACA,0BACF;AACE,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,SAAS;AAAA,UACT,QAAQ;AAAA,UACR;AAAA,UACA,SAAS;AAAA,YACL,UAAU;AAAA,YACV;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAAkC,OAAO;AAAA,EACzD;AAAA,EAEA,MAAM,cAAc,SAAiB,QAA2B;AAC5D,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,SAAS;AAAA,UACT,QAAQ;AAAA,QACZ,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAAqC,OAAO;AAAA,EAC5D;AAAA;AAAA;AAAA,EAMA,MAAM,SACF,SACA,SACA,SAAwB,OAC1B;AACE,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO,oCAAoC,MAAM,sBAAsB,OAAO;AAAA,MACtH;AAAA,QACI,QAAQ;AAAA,MACZ;AAAA,IACJ;AAEA,WAAO,KAAK,QAAgC,OAAO;AAAA,EACvD;AAAA,EAEA,MAAM,WAAW,SAAiB,IAAa;AAC3C,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO,kBAAkB,MAAM,EAAE;AAAA,IAC7E;AAEA,WAAO,KAAK,QAAkC,OAAO;AAAA,EACzD;AAAA,EAEA,MAAM,SAAS,SAAiB,IAAY,SAAiB;AACzD,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO,kBAAkB,EAAE,sBAAsB,OAAO;AAAA,MAChG;AAAA,QACI,QAAQ;AAAA,MACZ;AAAA,IACJ;AAEA,WAAO,KAAK,QAAgC,OAAO;AAAA,EACvD;AAAA,EAEA,MAAM,SAAS,SAAiB,IAAY;AACxC,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO,kBAAkB,EAAE;AAAA,MACnE;AAAA,QACI,QAAQ;AAAA,MACZ;AAAA,IACJ;AAEA,WAAO,KAAK,QAAgC,OAAO;AAAA,EACvD;AAAA;AAAA;AAAA,EAMA,MAAM,cAAc,IAAY,SAAkB;AAC9C,UAAM,SAAS,UAAU,mBAAmB,OAAO,KAAK;AACxD,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,EAAE,IAAI,MAAM;AAAA,IACxD;AAEA,WAAO,KAAK,QAAqC,OAAO;AAAA,EAC5D;AAAA,EAEA,MAAM,YAAY,SAAiB,MAAe,QAAQ,MAAM;AAC5D,QAAI,OAAO;AACP,UACI,CAAC,QACD,OAAO,SAAS,YAChB,EAAE,SAAS,SACX,OAAO,KAAK,QAAQ;AAEpB,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAEJ,YAAM,OAAO,KAAK,IAAI,MAAM;AAE5B,UAAI,CAAC,KAAK;AACN,cAAM,IAAI,MAAM,wCAAwC;AAE5D,YAAM,kBAAkB;AAAA,QACpB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAEA,UAAI,CAAC,gBAAgB,SAAS,KAAK,IAAI;AACnC,cAAM,IAAI,MAAM,uBAAuB,KAAK,IAAI,EAAE;AAEtD,YAAM,kBAAkB;AAAA,QACpB,OAAO;AAAA,QACP,MAAM;AAAA,QACN,aAAa;AAAA,QACb,OAAO;AAAA,QACP,OAAO;AAAA,QACP,SAAS;AAAA,MACb;AAEA,YAAM,YACF,KAAK,SAAS,eACR,YACC,KAAK,KAAK,MAAM,GAAG,EAAE,CAAC;AAEjC,UAAI,KAAK,QAAQ,KAAK,OAAO,gBAAgB,SAAS;AAClD,cAAM,IAAI;AAAA,UACN,oBAAoB,KAAK,IAAI,iBAAiB,SAAS,KAAK,gBAAgB,SAAS,CAAC;AAAA,QAC1F;AAAA,IACR;AAEA,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,OAAO;AAAA,MAC/C;AAAA,QACI,QAAQ;AAAA,QACR,MAAM;AAAA,MACV;AAAA,IACJ;AAEA,WAAO,KAAK,QAAmC,OAAO;AAAA,EAC1D;AAAA,EAEA,WAAW,KAAa;AAMpB,WAAO,KAAK,aAAa,IAAI,IAAI,GAAG,GAAG;AAAA,MACnC,SAAS;AAAA;AAAA,QAEL,cACI;AAAA,MACR;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,YAAY,IAAY,SAAkB;AAC5C,UAAM,SAAS,UAAU,mBAAmB,OAAO,KAAK;AACxD,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,KAAK,CAAC,IAAI,EAAE,IAAI,MAAM;AAAA,MACpD;AAAA,QACI,QAAQ;AAAA,MACZ;AAAA,IACJ;AAEA,WAAO,KAAK,QAAmC,OAAO;AAAA,EAC1D;AAAA;AAAA;AAAA,EAMA,MAAM,UAAU,YAAoB,OAAiB;AACjD,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,aAAa,MAAM,IAAI,CAAC,UAAU,EAAE,KAAK,EAAE;AAAA,QAC/C,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAA6B,OAAO;AAAA,EACpD;AAAA,EAEA,MAAM,YAAY,YAAoB,OAAiB;AACnD,UAAM,UAAU,KAAK;AAAA,MACjB,8BAA8B,OAAO;AAAA,MACrC;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,QACA,MAAM,KAAK,UAAU;AAAA,UACjB,mBAAmB;AAAA,UACnB,aAAa,MAAM,IAAI,CAAC,UAAU,EAAE,KAAK,EAAE;AAAA,QAC/C,CAAC;AAAA,MACL;AAAA,IACJ;AAEA,WAAO,KAAK,QAA+B,OAAO;AAAA,EACtD;AAAA,EAcA,MAAM,KAAK,MAAgB,UAAmB,WAAoB;AAE9D,QAAI,KAAK,QAAQ;AACb,UAAI,CAAC,SAAU,OAAM,IAAI,+BAA+B;AACxD,UAAI,CAAC,UAAW,OAAM,IAAI,iCAAiC;AAE3D,UAAI,CAAE,MAAM,KAAK,uBAAuB,UAAU,SAAS,GAAI;AAC3D,cAAM,IAAI,+BAA+B;AAAA,MAC7C;AAAA,IACJ;AAGA,QAAI,CAAC,KAAK,QAAQ;AACd,YAAM,IAAI,2BAA2B,mBAAmB,GAAG;AAAA,IAC/D;AAEA,UAAM,EAAE,OAAO,MAAM,IAAI,KAAK,MAAM,CAAC,EAAE,QAAQ,CAAC;AAChD,UAAM,UAAU,MAAM,SAAS;AAG/B,QAAI,UAAU,YAAY;AACtB,UAAI,SAAS,OAAO;AAChB,cAAM,UAAU,MAAM,SAAS,CAAC;AAEhC,cAAM,UAAU,MAAM,WAAW,CAAC;AAElC,cAAM,OAAO,SAAS,SAAS,QAAQ;AACvC,cAAM,OAAO,SAAS,QAAQ;AAE9B,cAAM,OAAsB;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAK;AAAA,UACL,OAAO,CACH,UACA,UAAU,OACV,6BAEA,KAAK;AAAA,YACD;AAAA,YACA;AAAA,YACA;AAAA,YACA,UAAU,QAAQ,KAAK;AAAA,YACvB;AAAA,UACJ;AAAA,UACJ,UAAU,CAAC,MAAM,KAAK,WAAW,SAAS,QAAQ,IAAI,CAAC;AAAA,UACvD,OAAO,MAAM,KAAK,UAAU,SAAS,IAAI;AAAA,UACzC,SAAS,YAAY;AAAA,UACrB,UAAU;AAAA,QACd;AAEA,eAAO,KAAK,IAAI,UAAU,IAAI;AAAA,MAClC,WAAW,cAAc,OAAO;AAC5B,cAAM,WAAW,MAAM,SAAS,CAAC;AAEjC,cAAM,QAAQ,SAAS;AACvB,cAAM,SAAS,SAAS;AACxB,cAAM,KAAK,SAAS;AACpB,cAAM,YAAY,SAAS;AAC3B,cAAM,eAAe,SAAS;AAC9B,cAAM,UAAU,SAAS;AACzB,cAAM,QAAQ,SAAS,SAAS,CAAC;AACjC,cAAM,2BACF,SAAS;AAEb,cAAM,OAAqB;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAK;AAAA,UACL,SAAS,YAAY;AAAA,UACrB,UAAU;AAAA,QACd;AAEA,eAAO,KAAK,IAAI,SAAS,IAAI;AAAA,MACjC;AAAA,IACJ,WAAW,UAAU,SAAS;AAC1B,UAAI,SAAS,OAAO;AAChB,cAAM,OAAO,MAAM,MAAM,CAAC;AAE1B,cAAM,UAAU,MAAM,WAAW,CAAC;AAElC,cAAM,OAAO,SAAS,SAAS,KAAK;AACpC,cAAM,OAAO,SAAS,QAAQ;AAE9B,YAAI,KAAK,UAAU,WAAW;AAC1B,gBAAM,OAA0B;AAAA,YAC5B;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,KAAK;AAAA,YACL,WAAW,MACP,KAAK;AAAA,cACD;AAAA,cACA,KAAK;AAAA,cACL,KAAK,QAAQ;AAAA,YACjB;AAAA,YACJ,QAAQ,CAAC,6BACL,KAAK;AAAA,cACD;AAAA,cACA,KAAK;AAAA,cACL,KAAK,QAAQ;AAAA,cACb;AAAA,YACJ;AAAA,YACJ,QAAQ,MAAM,KAAK,WAAW,SAAS,KAAK,EAAE;AAAA,YAC9C,WAAW,MAAM,KAAK,cAAc,SAAS,KAAK,EAAE;AAAA,YACpD,SAAS,YAAY;AAAA,YACrB,UAAU;AAAA,UACd;AAEA,iBAAO,KAAK,IAAI,MAAM,UAAU,IAAI;AAAA,QACxC,WAAW,KAAK,UAAU,aAAa;AACnC,gBAAM,OAA4B;AAAA,YAC9B;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,KAAK;AAAA,YACL,SAAS,YAAY;AAAA,YACrB,UAAU;AAAA,UACd;AAEA,iBAAO,KAAK,IAAI,MAAM,YAAY,IAAI;AAAA,QAC1C;AAAA,MACJ,WAAW,cAAc,OAAO;AAC5B,cAAM,WAAW,MAAM,SAAS,CAAC;AAEjC,cAAM,QAAQ,SAAS;AACvB,cAAM,SAAS,SAAS;AACxB,cAAM,KAAK,SAAS;AACpB,cAAM,YAAY,SAAS;AAC3B,cAAM,2BACF,SAAS;AAEb,cAAM,OAAyB;AAAA,UAC3B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,KAAK;AAAA,UACL,SAAS,YAAY;AAAA,UACrB,UAAU;AAAA,QACd;AAEA,eAAO,KAAK,IAAI,MAAM,SAAS,IAAI;AAAA,MACvC;AAAA,IACJ;AAIA,UAAM,IAAI,2BAA2B,sBAAsB,GAAG;AAAA,EAClE;AAAA,EAEA,IAAI,QAAmB;AACnB,QAAI,CAAC,KAAK,oBAAoB;AAC1B,YAAM,IAAI,mCAAmC;AAAA,IACjD;AAGA,UAAM;AAAA,MACF,YAAY;AAAA,MACZ,oBAAoB;AAAA,MACpB,iBAAiB;AAAA,IACrB,IAAI;AAGJ,QAAI,CAAC,QAAQ,CAAC,OAAO;AACjB,YAAM,IAAI,oCAAoC;AAAA,IAClD;AAGA,QAAI,SAAS,eAAe,UAAU,KAAK,oBAAoB;AAC3D,aAAO;AAAA,IACX;AAGA,UAAM,IAAI,oCAAoC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAM,aACF,KACA,UAAuB,CAAC,GACP;AACjB,WAAO,KAAK,MAAM,KAAK;AAAA,MACnB,GAAG;AAAA,MACH,SAAS;AAAA,QACL,eAAe,UAAU,KAAK,KAAK;AAAA,QACnC,GAAG,QAAQ;AAAA,MACf;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,uBACF,UACA,WACgB;AAChB,QAAI,CAAC,KAAK,UAAW,OAAM,IAAI,iCAAiC;AAChE,QAAI,CAAC,KAAK,OAAQ,OAAM,IAAI,oCAAoC;AAEhE,gBAAY,UAAU,MAAM,SAAS,EAAE,CAAC;AACxC,QAAI,CAAC,UAAW,QAAO;AAEvB,UAAM,UAAU,IAAI,YAAY;AAChC,UAAM,YAAY,QAAQ,OAAO,KAAK,SAAS;AAE/C,UAAM,MAAM,MAAM,KAAK,OAAO;AAAA,MAC1B;AAAA,MACA;AAAA,MACA,EAAE,MAAM,QAAQ,MAAM,UAAU;AAAA,MAChC;AAAA,MACA,CAAC,QAAQ,QAAQ;AAAA,IACrB;AAEA,UAAM,OAAO,QAAQ,OAAO,cAAc,QAAQ,CAAC;AACnD,UAAM,SAAS,MAAM,KAAK,OAAO,KAAK,QAAQ,KAAK,IAAI;AACvD,UAAM,eAAe,MAAM,KAAK,IAAI,WAAW,MAAM,CAAC;AAGtD,UAAM,QAAQ,aACT,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAC1C,KAAK,EAAE;AAEZ,WAAO,cAAc;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,QAAW,SAAwC;AAC7D,YAAQ,MAAM,SAAS,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,QAAQ,GAAkB;AAE7B,YAAQ,QAAQ,EAAE,KAAK,CAAC;AAAA,EAC5B;AACJ;",
  "names": []
}
