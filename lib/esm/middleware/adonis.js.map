{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/middleware/globals.ts", "../../../src/utils.ts", "../../../src/middleware/adonis.ts"],
  "sourcesContent": ["/** @module WhatsAppAPI */\n\nimport type {\n    WhatsAppAPIConstructorArguments,\n    PostData,\n    GetParams,\n    ClientMessage,\n    ClientMessageRequest,\n    ServerMessageResponse,\n    ServerMarkAsReadResponse,\n    ServerCreateQRResponse,\n    ServerRetrieveQRResponse,\n    ServerUpdateQRResponse,\n    ServerDeleteQRResponse,\n    ServerMediaRetrieveResponse,\n    ServerMediaUploadResponse,\n    ServerMediaDeleteResponse\n} from \"./types\";\nimport type {\n    OnMessage,\n    OnMessageArgs,\n    OnSent,\n    OnSentArgs,\n    OnStatus,\n    OnStatusArgs\n} from \"./emitters\";\n\nimport type { fetch as FetchType, Request, Response, FormData } from \"undici\";\nimport type { subtle as CryptoSubtle } from \"node:crypto\";\nimport type { Blob } from \"node:buffer\";\n\n/**\n * The main API Class\n */\nexport default class WhatsAppAPI {\n    //#region Properties\n    /**\n     * The API token\n     */\n    private token: string;\n    /**\n     * The app secret\n     */\n    private appSecret?: string;\n    /**\n     * The webhook verify token\n     */\n    private webhookVerifyToken?: string;\n    /**\n     * The API version to use\n     */\n    private v: string;\n    /**\n     * The fetch function for the requests\n     */\n    private fetch: typeof FetchType;\n    /**\n     * The CryptoSubtle library for checking the signatures\n     */\n    private subtle?: typeof CryptoSubtle;\n    /**\n     * If true, API operations will return the fetch promise instead. Intended for low level debugging.\n     */\n    private parsed: boolean;\n    /**\n     * If false, the API will be used in a less secure way, reducing the need for appSecret. Defaults to true.\n     */\n    private secure: boolean;\n    /**\n     * The callbacks for the events (message, sent, status)\n     *\n     * @example\n     * ```ts\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"my-token\",\n     *     appSecret: \"my-app-secret\"\n     * });\n     *\n     * // Set the callback\n     * Whatsapp.on.message = ({ from, phoneID }) => console.log(`Message from ${from} to bot ${phoneID}`);\n     *\n     * // Remove the callback\n     * Whatsapp.on.message = undefined;\n     * ```\n     */\n    public on: {\n        message?: OnMessage;\n        sent?: OnSent;\n        status?: OnStatus;\n    } = {};\n    //#endregion\n\n    /**\n     * Main entry point for the API.\n     *\n     * It's highly recommended reading the named parameters docs at\n     * {@link types.TheBasicConstructorArguments},\n     * at least for `token`, `appSecret` and `webhookVerifyToken` properties,\n     * which are the most common in normal usage.\n     *\n     * The other parameters are used for fine tunning the framework,\n     * such as `ponyfill`, which allows the code to execute on platforms\n     * that are missing standard APIs such as fetch and crypto.\n     *\n     * @throws If fetch is not defined in the enviroment and the provided ponyfill isn't a function\n     * @throws If secure is true, crypto.subtle is not defined in the enviroment and the provided ponyfill isn't an object\n     */\n    constructor({\n        token,\n        appSecret,\n        webhookVerifyToken,\n        v = \"v18.0\",\n        parsed = true,\n        secure = true,\n        ponyfill = {}\n    }: WhatsAppAPIConstructorArguments) {\n        this.token = token;\n        this.secure = !!secure;\n\n        if (this.secure) {\n            this.appSecret = appSecret;\n\n            if (\n                typeof ponyfill.subtle !== \"object\" &&\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - crypto might not be defined in the enviroment\n                (typeof crypto !== \"object\" ||\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore - crypto.subtle might not be defined in the enviroment\n                    typeof crypto?.subtle !== \"object\")\n            ) {\n                throw new Error(\n                    \"subtle is not defined in the enviroment, please provide a valid ponyfill object with the parameter 'ponyfill.subtle'.\"\n                );\n            }\n\n            // Let's hope the user is using a valid ponyfill\n            this.subtle =\n                ponyfill.subtle ||\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - crypto.subtle might not be defined in the enviroment\n                // Splitted in two lines to reduce the impact of the ts-ignore\n                crypto.subtle;\n        }\n\n        if (webhookVerifyToken) this.webhookVerifyToken = webhookVerifyToken;\n\n        if (\n            typeof ponyfill.fetch !== \"function\" &&\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore - fetch might not be defined in the enviroment\n            typeof fetch !== \"function\"\n        ) {\n            throw new Error(\n                \"fetch is not defined in the enviroment, please provide a valid ponyfill function with the parameter 'ponyfill.fetch'.\"\n            );\n        }\n\n        // Let's hope the user is using a valid ponyfill\n        this.fetch =\n            ponyfill.fetch ||\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore - fetch might not be defined in the enviroment\n            // Splitted in two lines to reduce the impact of the ts-ignore\n            fetch;\n\n        this.v = v;\n\n        this.parsed = !!parsed;\n    }\n\n    //#region Message Operations\n\n    /**\n     * Send a Whatsapp message\n     *\n     * @example\n     * ```ts\n     * import WhatsAppAPI from \"whatsapp-api-js\";\n     * import Text from \"whatsapp-api-js/messages/text\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\"\n     * });\n     *\n     * Whatsapp.sendMessage(\n     *     \"BOT_PHONE_ID\",\n     *     \"USER_PHONE\",\n     *     new Text(\"Hello World\")\n     * ).then(console.log);\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param to - The user's phone number\n     * @param message - A Whatsapp message, built using the corresponding module for each type of message.\n     * @param context - The message ID of the message to reply to\n     * @returns The server response\n     */\n    async sendMessage(\n        phoneID: string,\n        to: string,\n        message: ClientMessage,\n        context?: string\n    ): Promise<ServerMessageResponse | Response> {\n        const type = message._type;\n\n        const request = {\n            messaging_product: \"whatsapp\",\n            type,\n            to\n        } as ClientMessageRequest;\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - TS dumb, the _type will always match the type\n        request[type] =\n            // Prettier will probably kill me, but this comment has a purpose.\n            // It prevents ts-ignore from ignoring more than intended.\n            message._build();\n\n        if (context) request.context = { message_id: context };\n\n        // Make the post request\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(request)\n            }\n        );\n\n        const response = this.parsed\n            ? ((await (await promise).json()) as ServerMessageResponse)\n            : undefined;\n\n        const args: OnSentArgs = {\n            phoneID,\n            to,\n            type,\n            message,\n            request,\n            id: response\n                ? \"messages\" in response\n                    ? response.messages[0].id\n                    : undefined\n                : undefined,\n            response\n        };\n\n        this.offload(this.on?.sent, args);\n\n        return response ?? promise;\n    }\n\n    /**\n     * Send the same Whatsapp message to multiple phone numbers.\n     *\n     * In order to avoid reaching the\n     * [API rate limit](https://developers.facebook.com/docs/whatsapp/cloud-api/overview?locale=en_US#throughput),\n     * this method will send the messages in batches of 50 per second by default,\n     * but this can be changed using the `batch_size` and `delay` parameters.\n     *\n     * The API rate limit can be increased by contacting Facebook as explained\n     * [here](https://developers.facebook.com/docs/whatsapp/cloud-api/overview?locale=en_US#throughput).\n     *\n     * @example\n     * ```ts\n     * import WhatsAppAPI from \"whatsapp-api-js\";\n     * import Text from \"whatsapp-api-js/messages/text\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\"\n     * });\n     *\n     * const phoneID = \"YOUR_BOT_NUMBER\";\n     * const users = [\"YOUR_USER1_NUMBER\", \"YOUR_USER2_NUMBER\"];\n     * const message = new Text(\"Hello World\");\n     *\n     * const responses = Whatsapp.broadcastMessage(phoneID, users, message);\n     *\n     * Promise.all(responses).then(console.log);\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param to - The users' phone numbers\n     * @param message - A Whatsapp message, built using the corresponding module for each type of message.\n     * @param batch_size - The number of messages to send per batch\n     * @param delay - The delay between each batch of messages in milliseconds\n     * @returns The server response\n     * @throws if batch_size is lower than 1\n     * @throws if delay is lower than 0\n     */\n    async broadcastMessage(\n        phoneID: string,\n        to: string[],\n        message: ClientMessage,\n        batch_size = 50,\n        delay = 1000\n    ): Promise<Array<ReturnType<typeof this.sendMessage>>> {\n        const responses = [] as ReturnType<typeof this.sendMessage>[];\n\n        if (batch_size < 1) {\n            throw new RangeError(\"batch_size must be greater than 0\");\n        }\n\n        if (delay < 0) {\n            throw new RangeError(\"delay must be greater or equal to 0\");\n        }\n\n        for (let i = 0; i < to.length; i += batch_size) {\n            if (i !== 0) {\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n\n            for (const u of to.slice(i, i + batch_size)) {\n                responses.push(this.sendMessage(phoneID, u, message));\n            }\n        }\n\n        return responses;\n    }\n\n    /**\n     * Mark a message as read\n     *\n     * @param phoneID - The bot's phone ID\n     * @param messageId - The message ID\n     * @returns The server response\n     */\n    async markAsRead(\n        phoneID: string,\n        messageId: string\n    ): Promise<ServerMarkAsReadResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    status: \"read\",\n                    message_id: messageId\n                })\n            }\n        );\n\n        return this.getBody<ServerMarkAsReadResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region QR Operations\n\n    /**\n     * Generate a QR code for sharing the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param message - The quick message on the QR code\n     * @param format - The format of the QR code\n     * @returns The server response\n     */\n    async createQR(\n        phoneID: string,\n        message: string,\n        format: \"png\" | \"svg\" = \"png\"\n    ): Promise<ServerCreateQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls?generate_qr_image=${format}&prefilled_message=${message}`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerCreateQRResponse>(promise);\n    }\n\n    /**\n     * Get one or many QR codes of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to find. If not specified, all QRs will be returned\n     * @returns The server response\n     */\n    async retrieveQR(\n        phoneID: string,\n        id?: string\n    ): Promise<ServerRetrieveQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${\n                id ?? \"\"\n            }`,\n            {\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerRetrieveQRResponse>(promise);\n    }\n\n    /**\n     * Update a QR code of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to edit\n     * @param message - The new quick message for the QR code\n     * @returns The server response\n     */\n    async updateQR(\n        phoneID: string,\n        id: string,\n        message: string\n    ): Promise<ServerUpdateQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}?prefilled_message=${message}`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerUpdateQRResponse>(promise);\n    }\n\n    /**\n     * Delete a QR code of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to delete\n     * @returns The server response\n     */\n    async deleteQR(\n        phoneID: string,\n        id: string\n    ): Promise<ServerDeleteQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}`,\n            {\n                method: \"DELETE\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerDeleteQRResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region Media Operations\n\n    /**\n     * Get a Media object data with an ID\n     *\n     * @param id - The Media's ID\n     * @param phoneID - Business phone number ID. If included, the operation will only be processed if the ID matches the ID of the business phone number that the media was uploaded on.\n     * @returns The server response\n     */\n    async retrieveMedia(\n        id: string,\n        phoneID?: string\n    ): Promise<ServerMediaRetrieveResponse | Response> {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`,\n            {\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerMediaRetrieveResponse>(promise);\n    }\n\n    /**\n     * Upload a Media to the server\n     *\n     * @param phoneID - The bot's phone ID\n     * @param form - The Media's FormData. Must have a 'file' property with the file to upload as a blob and a valid mime-type in the 'type' field of the blob. Example for Node ^18: new FormData().set(\"file\", new Blob([stringOrFileBuffer], \"image/png\")); Previous versions of Node will need an external FormData, such as undici's. To use non spec complaints versions of FormData (eg: form-data) or Blob set the 'check' parameter to false.\n     * @param check - If the FormData should be checked before uploading. The FormData must have the method .get(\"name\") to work with the checks. If it doesn't (for example, using the module \"form-data\"), set this to false.\n     * @returns The server response\n     * @throws If check is set to true and form is not a FormData\n     * @throws If check is set to true and the form doesn't have valid required properties (file, type)\n     * @throws If check is set to true and the form file is too big for the file type\n     * @example\n     * ```ts\n     * import WhatsAppAPI from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * // If required:\n     * // import FormData from \"undici\";\n     * // import { Blob } from \"node:buffer\";\n     *\n     * const form = new FormData();\n     *\n     * // If you don't mind reading the whole file into memory:\n     * form.set(\"file\", new Blob([fs.readFileSync(\"image.png\")], \"image/png\"));\n     *\n     * // If you do, you will need to use streams. The module \"form-data\",\n     * // although not spec compliant (hence needing to set check to false),\n     * // has an easy way to do this:\n     * // form.append(\"file\", fs.createReadStream(\"image.png\"), { contentType: \"image/png\" });\n     *\n     * console.log(await Whatsapp.uploadMedia(\"phoneID\", form));\n     * // Expected output: { id: \"mediaID\" }\n     * ```\n     */\n    async uploadMedia(\n        phoneID: string,\n        form: unknown,\n        check = true\n    ): Promise<ServerMediaUploadResponse | Response> {\n        if (check) {\n            if (\n                !form ||\n                typeof form !== \"object\" ||\n                !(\"get\" in form) ||\n                typeof form.get !== \"function\"\n            )\n                throw new TypeError(\n                    \"File's Form must be an instance of FormData\"\n                );\n\n            const file = form.get(\"file\") as Blob;\n\n            if (!file.type)\n                throw new Error(\"File's Blob must have a type specified\");\n\n            const validMediaTypes = [\n                \"audio/aac\",\n                \"audio/mp4\",\n                \"audio/mpeg\",\n                \"audio/amr\",\n                \"audio/ogg\",\n                \"text/plain\",\n                \"application/pdf\",\n                \"application/vnd.ms-powerpoint\",\n                \"application/msword\",\n                \"application/vnd.ms-excel\",\n                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n                \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n                \"image/jpeg\",\n                \"image/png\",\n                \"video/mp4\",\n                \"video/3gp\",\n                \"image/webp\"\n            ];\n\n            if (!validMediaTypes.includes(file.type))\n                throw new Error(`Invalid media type: ${file.type}`);\n\n            const validMediaSizes = {\n                audio: 16_000_000,\n                text: 100_000_000,\n                application: 100_000_000,\n                image: 5_000_000,\n                video: 16_000_000,\n                sticker: 500_000\n            };\n\n            const mediaType =\n                file.type === \"image/webp\"\n                    ? \"sticker\"\n                    : (file.type.split(\"/\")[0] as keyof typeof validMediaSizes);\n\n            if (file.size && file.size > validMediaSizes[mediaType])\n                throw new Error(\n                    `File is too big (${file.size} bytes) for a ${mediaType} (${validMediaSizes[mediaType]} bytes limit)`\n                );\n        }\n\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/media?messaging_product=whatsapp`,\n            {\n                method: \"POST\",\n                body: form as FormData,\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    \"Content-Type\": \"multipart/form-data\"\n                }\n            }\n        );\n\n        return this.getBody<ServerMediaUploadResponse>(promise);\n    }\n\n    /**\n     * Get a Media fetch from an url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * @param url - The Media's url\n     * @returns The fetch raw response\n     * @throws If url is not a valid url\n     * @example\n     * ```ts\n     * import WhatsAppAPI from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * const id = \"mediaID\";\n     * const { url } = await Whatsapp.retrieveMedia(id);\n     * const response = Whatsapp.fetchMedia(url);\n     * ```\n     */\n    fetchMedia(url: string): Promise<Response> {\n        // Hacky way to check if the url is valid and throw if invalid\n        return this._authenicatedRequest(new URL(url));\n    }\n\n    /**\n     * Delete a Media object with an ID\n     *\n     * @param id - The Media's ID\n     * @param phoneID - Business phone number ID. If included, the operation will only be processed if the ID matches the ID of the business phone number that the media was uploaded on.\n     * @returns The server response\n     */\n    async deleteMedia(\n        id: string,\n        phoneID?: string\n    ): Promise<ServerMediaDeleteResponse | Response> {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`,\n            {\n                method: \"DELETE\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerMediaDeleteResponse>(promise);\n    }\n\n    // #endregion\n\n    // #region Webhooks\n\n    /**\n     * POST helper, must be called inside the post function of your code.\n     * When setting up the webhook, only subscribe to messages. Other subscritions support might be added later.\n     *\n     * @example\n     * ```ts\n     * // author arivanbastos on issue #114\n     * // Simple http example implementation with Whatsapp.post() on Node@^19\n     * import WhatsAppAPI from \"whatsapp-api-js\";\n     * import { NodeNext } from \"whatsapp-api-js/setup/node\";\n     *\n     * import { createServer } from \"http\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     * const Whatsapp = new WhatsAppAPI(NodeNext({ token, appSecret }));\n     *\n     * function handler(req, res) {\n     *     if (req.method == \"POST\") {\n     *         const chunks = [];\n     *         req.on(\"data\", (chunk) => chunks.push(chunk));\n     *\n     *         req.on(\"end\", async () => {\n     *             const body = Buffer.concat(chunks).toString();\n     *\n     *             try {\n     *                 const response = await Whatsapp.post(JSON.parse(body), body, req.headers[\"x-hub-signature-256\"]);\n     *                 res.writeHead(response);\n     *             } catch (err) {\n     *                 res.writeHead(err);\n     *             }\n     *\n     *             res.end();\n     *         });\n     *     } else res.writeHead(501).end();\n     * };\n     *\n     * Whatsapp.on.message = ({ phoneID, from, message, name }) => {\n     *     console.log(`User ${name} (${from}) sent to bot ${phoneID} a(n) ${message.type}`);\n     * };\n     *\n     * const server = createServer(handler);\n     * server.listen(3000);\n     * ```\n     *\n     * @param data - The POSTed data object sent by Whatsapp\n     * @param raw_body - The raw body of the POST request\n     * @param signature - The x-hub-signature-256 (all lowercase) header signature sent by Whatsapp\n     * @returns 200, it's the expected http/s response code\n     * @throws 500 if secure and the appSecret isn't specified\n     * @throws 501 if secure and crypto.subtle or ponyfill isn't available\n     * @throws 400 if secure and the raw body is missing\n     * @throws 401 if secure and the signature is missing\n     * @throws 401 if secure and the signature doesn't match the hash\n     * @throws 400 if the POSTed data is not a valid Whatsapp API request\n     */\n    async post(\n        data: PostData,\n        raw_body?: string,\n        signature?: string\n    ): Promise<200> {\n        //Validating the payload\n        if (this.secure) {\n            if (!this.appSecret) throw 500;\n            if (!this.subtle) throw 501;\n\n            if (!raw_body) throw 400;\n\n            signature = signature?.split(\"sha256=\")[1];\n            if (!signature) throw 401;\n\n            const encoder = new TextEncoder();\n            const keyBuffer = encoder.encode(this.appSecret);\n\n            const key = await this.subtle.importKey(\n                \"raw\",\n                keyBuffer,\n                { name: \"HMAC\", hash: \"SHA-256\" },\n                true,\n                [\"sign\", \"verify\"]\n            );\n\n            const data = encoder.encode(raw_body);\n            const result = await this.subtle.sign(\"HMAC\", key, data.buffer);\n            const result_array = Array.from(new Uint8Array(result));\n\n            // Convert an array of bytes to a hex string\n            const check = result_array\n                .map((b) => b.toString(16).padStart(2, \"0\"))\n                .join(\"\");\n\n            if (signature !== check) throw 401;\n        }\n\n        // Throw \"400 Bad Request\" if data is not a valid WhatsApp API request\n        if (!data.object) throw 400;\n\n        const value = data.entry[0].changes[0].value;\n        const phoneID = value.metadata.phone_number_id;\n\n        // Check if the message is a message or a status update\n        if (\"messages\" in value) {\n            const message = value.messages[0];\n\n            const contact = value.contacts?.[0];\n\n            const from = contact?.wa_id ?? message.from;\n            const name = contact?.profile.name;\n\n            const args: OnMessageArgs = {\n                phoneID,\n                from,\n                message,\n                name,\n                raw: data\n            };\n\n            this.offload(this.on?.message, args);\n        } else if (\"statuses\" in value) {\n            const statuses = value.statuses[0];\n\n            const phone = statuses.recipient_id;\n            const status = statuses.status;\n            const id = statuses.id;\n            const conversation = statuses.conversation;\n            const pricing = statuses.pricing;\n            const error = statuses.errors?.[0];\n\n            const args: OnStatusArgs = {\n                phoneID,\n                phone,\n                status,\n                id,\n                conversation,\n                pricing,\n                error,\n                raw: data\n            };\n\n            this.offload(this.on?.status, args);\n        }\n        // If unknown payload, just ignore it\n        // Facebook doesn't care about your server's opinion\n\n        return 200;\n    }\n\n    /**\n     * GET helper, must be called inside the get function of your code.\n     * Used once at the first webhook setup.\n     *\n     * @param params - The request object sent by Whatsapp\n     * @returns The challenge string, it must be the http response body\n     * @throws 500 if webhookVerifyToken is not specified\n     * @throws 400 if the request is missing data\n     * @throws 403 if the verification tokens don't match\n     */\n    get(params: GetParams): string {\n        if (!this.webhookVerifyToken) throw 500;\n\n        // Parse params from the webhook verification request\n        const {\n            \"hub.mode\": mode,\n            \"hub.verify_token\": token,\n            \"hub.challenge\": challenge\n        } = params;\n\n        // Check if a token and mode were sent\n        if (!mode || !token) {\n            // Responds with \"400 Bad Request\" if it's missing data\n            throw 400;\n        }\n\n        // Check the mode and token sent are correct\n        if (mode === \"subscribe\" && token === this.webhookVerifyToken) {\n            // Respond with 200 OK and challenge token from the request\n            return challenge;\n        }\n\n        // Responds with \"403 Forbidden\" if verify tokens do not match\n        throw 403;\n    }\n\n    // #endregion\n\n    /**\n     * Make an authenticated request to any url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * @internal\n     * @param url - The url to request to\n     * @returns The fetch response\n     * @throws If url is not specified\n     */\n    _authenicatedRequest(url: string | URL | Request): Promise<Response> {\n        // Keep the check to ensure on runtime that no weird stuff happens\n        if (!url) throw new Error(\"URL must be specified\");\n\n        return this.fetch(url, {\n            headers: {\n                Authorization: `Bearer ${this.token}`\n            }\n        });\n    }\n\n    /**\n     * Get the body of a fetch response\n     *\n     * @param promise - The fetch response\n     * @returns The json body parsed\n     */\n    private async getBody<T>(\n        promise: Promise<Response>\n    ): Promise<T | Response> {\n        return this.parsed ? ((await (await promise).json()) as T) : promise;\n    }\n\n    /**\n     * Offload a function to the next tick of the event loop\n     *\n     * @internal\n     * @param f - The function to offload from the main thread\n     * @param a - The arguments to pass to the function\n     */\n    private offload<A, F extends ((...a: A[]) => unknown) | undefined>(\n        f: F,\n        ...a: A[]\n    ) {\n        if (f) {\n            // Thanks @RahulLanjewar93\n            Promise.resolve().then(() => f(...a));\n        }\n    }\n}\n", "import WhatsAppAPI from \"../index.js\";\n\n/**\n * The abstract class for the middlewares, it extends the WhatsAppAPI class\n * and defines the handle_post and handle_get methods for its childs.\n */\nexport abstract class WhatsAppAPIMiddleware extends WhatsAppAPI {\n    /**\n     * This method should be called when the server receives a POST request.\n     * Each child implements it differently depending on the framework.\n     *\n     * @returns The status code to be sent to the client\n     */\n    abstract handle_post(...a: unknown[]): Promise<number>;\n\n    /**\n     * This method should be called when the server receives a GET request.\n     * Each child implements it differently depending on the framework.\n     *\n     * @returns The challenge string to be sent to the client\n     * @throws The error code\n     */\n    abstract handle_get(...a: unknown[]): string;\n}\n", "export type AtLeastOne<T> = [T, ...T[]];\n\nexport function isInteger(n: unknown): n is number {\n    return Number.isInteger(n);\n}\n", "import { WhatsAppAPIMiddleware } from \"./globals.js\";\nimport { isInteger } from \"../utils.js\";\n\nimport type { Request } from \"@adonisjs/http-server/build/standalone\";\nimport type { GetParams, PostData } from \"../types\";\n\n/**\n * AdonisJS middleware for WhatsAppAPI\n */\nexport default class WhatsAppAPI extends WhatsAppAPIMiddleware {\n    /**\n     * POST request handler for AdonisJS\n     *\n     * @example\n     * ```ts\n     * import Route from \"@ioc:Adonis/Core/Route\";\n     * import WhatsAppAPI from \"whatsapp-api-js/middleware/adonis\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\",\n     *     webhookVerifyToken: \"YOUR_WEBHOOK_VERIFY_TOKEN\"\n     * });\n     *\n     * Route.post('/', async ({ request, response }) => {\n     *     response.status(await Whatsapp.handle_post(request));\n     * });\n     * ```\n     *\n     * @override\n     * @param req - The request object from AdonisJS\n     * @returns The status code to be sent to the client\n     */\n    async handle_post(req: Request) {\n        try {\n            return await this.post(\n                req.body() as PostData,\n                req.raw() ?? \"\",\n                req.header(\"x-hub-signature-256\") ?? \"\"\n            );\n        } catch (e) {\n            // In case who knows what fails \u00AF\\_(\u30C4)_/\u00AF\n            return isInteger(e) ? e : 500;\n        }\n    }\n\n    /**\n     * GET request handler for AdonisJS\n     *\n     * @example\n     * ```ts\n     * import Route from \"@ioc:Adonis/Core/Route\";\n     * import WhatsAppAPI from \"whatsapp-api-js/middleware/adonis\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\",\n     *     webhookVerifyToken: \"YOUR_WEBHOOK_VERIFY_TOKEN\"\n     * });\n     *\n     * Route.get('/', ({ request, response }) => {\n     *     try {\n     *         return Whatsapp.handle_get(request);\n     *     } catch (e) {\n     *         response.status(e as number);\n     *     }\n     * });\n     * ```\n     *\n     * @override\n     * @param req - The request object from AdonisJS\n     * @returns The challenge string to be sent to the client\n     * @throws The error code\n     */\n    handle_get(req: Request) {\n        try {\n            return this.get(req.qs() as GetParams);\n        } catch (e) {\n            // In case who knows what fails \u00AF\\_(\u30C4)_/\u00AF\n            throw isInteger(e) ? e : 500;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["data", "WhatsAppAPI"]
}
