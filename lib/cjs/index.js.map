{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["/** @module WhatsAppAPI */\n\nimport type {\n    WhatsAppAPIConstructorArguments,\n    PostData,\n    GetParams,\n    ClientMessage,\n    ClientMessageRequest,\n    ServerMessageResponse,\n    ServerMarkAsReadResponse,\n    ServerCreateQRResponse,\n    ServerRetrieveQRResponse,\n    ServerUpdateQRResponse,\n    ServerDeleteQRResponse,\n    ServerMediaRetrieveResponse,\n    ServerMediaUploadResponse,\n    ServerMediaDeleteResponse\n} from \"./types\";\nimport type {\n    OnMessage,\n    OnMessageArgs,\n    OnSent,\n    OnSentArgs,\n    OnStatus,\n    OnStatusArgs\n} from \"./emitters\";\n\nimport { escapeUnicode } from \"./utils.js\";\nimport { DEFAULT_API_VERSION } from \"./types.js\";\n\n/**\n * The main API Class\n */\nexport class WhatsAppAPI {\n    //#region Properties\n    /**\n     * The API token\n     */\n    private token: string;\n    /**\n     * The app secret\n     */\n    private appSecret?: string;\n    /**\n     * The webhook verify token\n     */\n    private webhookVerifyToken?: string;\n    /**\n     * The API version to use\n     */\n    private v: string;\n    /**\n     * The fetch function for the requests\n     */\n    private fetch: typeof fetch;\n    /**\n     * The CryptoSubtle library for checking the signatures\n     */\n    private subtle?: Pick<typeof crypto.subtle, \"importKey\" | \"sign\">;\n    /**\n     * If true, API operations will return the fetch promise instead. Intended for low level debugging.\n     */\n    private parsed: boolean;\n    /**\n     * If false, the user functions won't be offloaded from the main event loop.\n     * Intended for Serverless Environments where the process might be killed after the main function finished.\n     */\n    private offload_functions: boolean;\n    /**\n     * If false, the API will be used in a less secure way, removing the need for appSecret. Defaults to true.\n     */\n    private secure: boolean;\n    /**\n     * The callbacks for the events (message, sent, status)\n     *\n     * @example\n     * ```ts\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"my-token\",\n     *     appSecret: \"my-app-secret\"\n     * });\n     *\n     * // Set the callback\n     * Whatsapp.on.message = ({ from, phoneID }) => console.log(`Message from ${from} to bot ${phoneID}`);\n     *\n     * // If you need to disable the callback:\n     * // Whatsapp.on.message = undefined;\n     * ```\n     */\n    public on: {\n        message?: OnMessage;\n        sent?: OnSent;\n        status?: OnStatus;\n    } = {};\n    //#endregion\n\n    /**\n     * Main entry point for the API.\n     *\n     * It's highly recommended reading the named parameters docs at\n     * {@link types.TheBasicConstructorArguments},\n     * at least for `token`, `appSecret` and `webhookVerifyToken` properties,\n     * which are the most common in normal usage.\n     *\n     * The other parameters are used for fine tunning the framework,\n     * such as `ponyfill`, which allows the code to execute on platforms\n     * that are missing standard APIs such as fetch and crypto.\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *    token: \"YOUR_TOKEN\",\n     *    appSecret: \"YOUR_APP_SECRET\"\n     * });\n     * ```\n     *\n     * @throws If fetch is not defined in the enviroment and the provided ponyfill isn't a function\n     * @throws If secure is true, crypto.subtle is not defined in the enviroment and the provided ponyfill isn't an object\n     */\n    constructor({\n        token,\n        appSecret,\n        webhookVerifyToken,\n        v,\n        parsed = true,\n        offload_functions = true,\n        secure = true,\n        ponyfill = {}\n    }: WhatsAppAPIConstructorArguments) {\n        this.token = token;\n        this.secure = !!secure;\n\n        if (this.secure) {\n            this.appSecret = appSecret;\n\n            if (\n                typeof ponyfill.subtle !== \"object\" &&\n                (typeof crypto !== \"object\" ||\n                    typeof crypto?.subtle !== \"object\")\n            ) {\n                throw new Error(\n                    \"subtle is not defined in the enviroment. Consider using a setup helper,\" +\n                        \" defined at 'whatsapp-api-js/setup', or provide a valid ponyfill\" +\n                        \" object with the argument 'ponyfill.subtle'.\"\n                );\n            }\n\n            // Let's hope the user is using a valid ponyfill\n            this.subtle = ponyfill.subtle || crypto.subtle;\n        }\n\n        if (webhookVerifyToken) this.webhookVerifyToken = webhookVerifyToken;\n\n        if (\n            typeof ponyfill.fetch !== \"function\" &&\n            typeof fetch !== \"function\"\n        ) {\n            throw new Error(\n                \"fetch is not defined in the enviroment. Consider using a setup helper,\" +\n                    \" defined at 'whatsapp-api-js/setup', or provide a valid ponyfill\" +\n                    \" object with the argument 'ponyfill.fetch'.\"\n            );\n        }\n\n        // Let's hope the user is using a valid ponyfill\n        this.fetch = ponyfill.fetch || fetch;\n\n        if (v) this.v = v;\n        else {\n            console.warn(\n                `[whatsapp-api-js] Cloud API version not defined. In production, it's strongly recommended pinning it to the desired version with the \"v\" argument. Defaulting to \"${DEFAULT_API_VERSION}\".`\n            );\n            this.v = DEFAULT_API_VERSION;\n        }\n\n        this.parsed = !!parsed;\n        this.offload_functions = !!offload_functions;\n    }\n\n    //#region Message Operations\n\n    /**\n     * Send a Whatsapp message\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { Text } from \"whatsapp-api-js/messages/text\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\"\n     * });\n     *\n     * Whatsapp.sendMessage(\n     *     \"BOT_PHONE_ID\",\n     *     \"USER_PHONE\",\n     *     new Text(\"Hello World\")\n     * ).then(console.log);\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param to - The user's phone number\n     * @param message - A Whatsapp message, built using the corresponding module for each type of message.\n     * @param context - The message ID of the message to reply to\n     * @param biz_opaque_callback_data - An arbitrary 512B string, useful for tracking (length not checked by the framework)\n     * @returns The server response\n     */\n    async sendMessage(\n        phoneID: string,\n        to: string,\n        message: ClientMessage,\n        context?: string,\n        biz_opaque_callback_data?: string\n    ): Promise<ServerMessageResponse | Response> {\n        const type = message._type;\n\n        const request = {\n            messaging_product: \"whatsapp\",\n            type,\n            to\n        } as ClientMessageRequest;\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - TS dumb, the _type will always match the type\n        request[type] =\n            // Prettier will probably kill me, but this comment has a purpose.\n            // It prevents ts-ignore from ignoring more than intended.\n            message._build();\n\n        if (context) request.context = { message_id: context };\n        if (biz_opaque_callback_data)\n            request.biz_opaque_callback_data = biz_opaque_callback_data;\n\n        // Make the post request\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(request)\n            }\n        );\n\n        const response = this.parsed\n            ? ((await (await promise).json()) as ServerMessageResponse)\n            : undefined;\n\n        const args: OnSentArgs = {\n            phoneID,\n            to,\n            type,\n            message,\n            request,\n            id: response\n                ? \"messages\" in response\n                    ? response.messages[0].id\n                    : undefined\n                : undefined,\n            response\n        };\n\n        this.user_function(this.on?.sent, args);\n\n        return response ?? promise;\n    }\n\n    /**\n     * Send the same Whatsapp message to multiple phone numbers.\n     *\n     * In order to avoid reaching the\n     * [API rate limit](https://developers.facebook.com/docs/whatsapp/cloud-api/overview?locale=en_US#throughput),\n     * this method will send the messages in batches of 50 per second by default,\n     * but this can be changed using the `batch_size` and `delay` parameters.\n     *\n     * The API rate limit can be increased by contacting Facebook as explained\n     * [here](https://developers.facebook.com/docs/whatsapp/cloud-api/overview?locale=en_US#throughput).\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { Text } from \"whatsapp-api-js/messages/text\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\"\n     * });\n     *\n     * const phoneID = \"YOUR_BOT_NUMBER\";\n     * const users = [\"YOUR_USER1_NUMBER\", \"YOUR_USER2_NUMBER\"];\n     * const message = new Text(\"Hello World\");\n     *\n     * const responses = Whatsapp.broadcastMessage(phoneID, users, message);\n     *\n     * Promise.all(responses).then(console.log);\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param to - The users' phone numbers\n     * @param message - A Whatsapp message, built using the corresponding module for each type of message.\n     * @param batch_size - The number of messages to send per batch\n     * @param delay - The delay between each batch of messages in milliseconds\n     * @returns The server's responses\n     * @throws if batch_size is lower than 1\n     * @throws if delay is lower than 0\n     */\n    async broadcastMessage(\n        phoneID: string,\n        to: string[],\n        message: ClientMessage,\n        batch_size = 50,\n        delay = 1000\n    ): Promise<Array<ReturnType<typeof this.sendMessage>>> {\n        const responses = [] as ReturnType<typeof this.sendMessage>[];\n\n        if (batch_size < 1) {\n            throw new RangeError(\"batch_size must be greater than 0\");\n        }\n\n        if (delay < 0) {\n            throw new RangeError(\"delay must be greater or equal to 0\");\n        }\n\n        for (let i = 0; i < to.length; i += batch_size) {\n            if (i !== 0) {\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n\n            for (const u of to.slice(i, i + batch_size)) {\n                responses.push(this.sendMessage(phoneID, u, message));\n            }\n        }\n\n        return responses;\n    }\n\n    /**\n     * Mark a message as read\n     *\n     * @param phoneID - The bot's phone ID\n     * @param messageId - The message ID\n     * @returns The server response\n     */\n    async markAsRead(\n        phoneID: string,\n        messageId: string\n    ): Promise<ServerMarkAsReadResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    status: \"read\",\n                    message_id: messageId\n                })\n            }\n        );\n\n        return this.getBody<ServerMarkAsReadResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region QR Operations\n\n    /**\n     * Generate a QR code for sharing the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param message - The quick message on the QR code\n     * @param format - The format of the QR code\n     * @returns The server response\n     */\n    async createQR(\n        phoneID: string,\n        message: string,\n        format: \"png\" | \"svg\" = \"png\"\n    ): Promise<ServerCreateQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls?generate_qr_image=${format}&prefilled_message=${message}`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerCreateQRResponse>(promise);\n    }\n\n    /**\n     * Get one or many QR codes of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to find. If not specified, all QRs will be returned\n     * @returns The server response\n     */\n    async retrieveQR(\n        phoneID: string,\n        id?: string\n    ): Promise<ServerRetrieveQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${\n                id ?? \"\"\n            }`,\n            {\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerRetrieveQRResponse>(promise);\n    }\n\n    /**\n     * Update a QR code of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to edit\n     * @param message - The new quick message for the QR code\n     * @returns The server response\n     */\n    async updateQR(\n        phoneID: string,\n        id: string,\n        message: string\n    ): Promise<ServerUpdateQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}?prefilled_message=${message}`,\n            {\n                method: \"POST\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerUpdateQRResponse>(promise);\n    }\n\n    /**\n     * Delete a QR code of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to delete\n     * @returns The server response\n     */\n    async deleteQR(\n        phoneID: string,\n        id: string\n    ): Promise<ServerDeleteQRResponse | Response> {\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}`,\n            {\n                method: \"DELETE\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerDeleteQRResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region Media Operations\n\n    /**\n     * Get a Media object data with an ID\n     *\n     * @see {@link fetchMedia}\n     *\n     * @param id - The Media's ID\n     * @param phoneID - Business phone number ID. If included, the operation will only be processed if the ID matches the ID of the business phone number that the media was uploaded on.\n     * @returns The server response\n     */\n    async retrieveMedia(\n        id: string,\n        phoneID?: string\n    ): Promise<ServerMediaRetrieveResponse | Response> {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`,\n            {\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerMediaRetrieveResponse>(promise);\n    }\n\n    /**\n     * Upload a Media to the API server\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * // If required:\n     * // import FormData from \"undici\";\n     * // import { Blob } from \"node:buffer\";\n     *\n     * const form = new FormData();\n     *\n     * // If you don't mind reading the whole file into memory:\n     * form.set(\"file\", new Blob([fs.readFileSync(\"image.png\")], \"image/png\"));\n     *\n     * // If you do, you will need to use streams. The module \"form-data\",\n     * // although not spec compliant (hence needing to set check to false),\n     * // has an easy way to do this:\n     * // form.append(\"file\", fs.createReadStream(\"image.png\"), { contentType: \"image/png\" });\n     *\n     * console.log(await Whatsapp.uploadMedia(\"phoneID\", form));\n     * // Expected output: { id: \"mediaID\" }\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param form - The Media's FormData. Must have a 'file' property with the file to upload as a blob and a valid mime-type in the 'type' field of the blob. Example for Node ^18: new FormData().set(\"file\", new Blob([stringOrFileBuffer], \"image/png\")); Previous versions of Node will need an external FormData, such as undici's. To use non spec complaints versions of FormData (eg: form-data) or Blob set the 'check' parameter to false.\n     * @param check - If the FormData should be checked before uploading. The FormData must have the method .get(\"name\") to work with the checks. If it doesn't (for example, using the module \"form-data\"), set this to false.\n     * @returns The server response\n     * @throws If check is set to true and form is not a FormData\n     * @throws If check is set to true and the form doesn't have valid required properties (file, type)\n     * @throws If check is set to true and the form file is too big for the file type\n     */\n    async uploadMedia(\n        phoneID: string,\n        form: unknown,\n        check = true\n    ): Promise<ServerMediaUploadResponse | Response> {\n        if (check) {\n            if (\n                !form ||\n                typeof form !== \"object\" ||\n                !(\"get\" in form) ||\n                typeof form.get !== \"function\"\n            )\n                throw new TypeError(\n                    \"File's Form must be an instance of FormData\"\n                );\n\n            const file = form.get(\"file\") as Blob;\n\n            if (!file.type)\n                throw new Error(\"File's Blob must have a type specified\");\n\n            const validMediaTypes = [\n                \"audio/aac\",\n                \"audio/mp4\",\n                \"audio/mpeg\",\n                \"audio/amr\",\n                \"audio/ogg\",\n                \"text/plain\",\n                \"application/pdf\",\n                \"application/vnd.ms-powerpoint\",\n                \"application/msword\",\n                \"application/vnd.ms-excel\",\n                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n                \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n                \"image/jpeg\",\n                \"image/png\",\n                \"video/mp4\",\n                \"video/3gp\",\n                \"image/webp\"\n            ];\n\n            if (!validMediaTypes.includes(file.type))\n                throw new Error(`Invalid media type: ${file.type}`);\n\n            const validMediaSizes = {\n                audio: 16_000_000,\n                text: 100_000_000,\n                application: 100_000_000,\n                image: 5_000_000,\n                video: 16_000_000,\n                sticker: 500_000\n            };\n\n            const mediaType =\n                file.type === \"image/webp\"\n                    ? \"sticker\"\n                    : (file.type.split(\"/\")[0] as keyof typeof validMediaSizes);\n\n            if (file.size && file.size > validMediaSizes[mediaType])\n                throw new Error(\n                    `File is too big (${file.size} bytes) for a ${mediaType} (${validMediaSizes[mediaType]} bytes limit)`\n                );\n        }\n\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${phoneID}/media?messaging_product=whatsapp`,\n            {\n                method: \"POST\",\n                body: form as FormData,\n                headers: {\n                    Authorization: `Bearer ${this.token}`,\n                    \"Content-Type\": \"multipart/form-data\"\n                }\n            }\n        );\n\n        return this.getBody<ServerMediaUploadResponse>(promise);\n    }\n\n    /**\n     * Get a Media fetch from an url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * const id = \"mediaID\";\n     * const { url } = await Whatsapp.retrieveMedia(id);\n     * const response = Whatsapp.fetchMedia(url);\n     * ```\n     *\n     * @param url - The Media's url\n     * @returns The fetch raw response\n     * @throws If url is not a valid url\n     */\n    fetchMedia(url: string): Promise<Response> {\n        // Hacky way to check if the url is valid and throw if invalid\n        return this._authenicatedRequest(new URL(url));\n    }\n\n    /**\n     * Delete a Media object with an ID\n     *\n     * @param id - The Media's ID\n     * @param phoneID - Business phone number ID. If included, the operation will only be processed if the ID matches the ID of the business phone number that the media was uploaded on.\n     * @returns The server response\n     */\n    async deleteMedia(\n        id: string,\n        phoneID?: string\n    ): Promise<ServerMediaDeleteResponse | Response> {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.fetch(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`,\n            {\n                method: \"DELETE\",\n                headers: {\n                    Authorization: `Bearer ${this.token}`\n                }\n            }\n        );\n\n        return this.getBody<ServerMediaDeleteResponse>(promise);\n    }\n\n    // #endregion\n\n    // #region Webhooks\n\n    /**\n     * POST helper, must be called inside the post function of your code.\n     * When setting up the webhook, only subscribe to messages. Other subscritions support might be added later.\n     *\n     * @example\n     * ```ts\n     * // author arivanbastos on issue #114\n     * // Simple http example implementation with Whatsapp.post() on Node@^19\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { NodeNext } from \"whatsapp-api-js/setup/node\";\n     *\n     * import { createServer } from \"http\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     * const Whatsapp = new WhatsAppAPI(NodeNext({ token, appSecret }));\n     *\n     * function handler(req, res) {\n     *     if (req.method == \"POST\") {\n     *         const chunks = [];\n     *         req.on(\"data\", (chunk) => chunks.push(chunk));\n     *\n     *         req.on(\"end\", async () => {\n     *             const body = Buffer.concat(chunks).toString();\n     *\n     *             try {\n     *                 const response = await Whatsapp.post(JSON.parse(body), body, req.headers[\"x-hub-signature-256\"]);\n     *                 res.writeHead(response);\n     *             } catch (err) {\n     *                 res.writeHead(err);\n     *             }\n     *\n     *             res.end();\n     *         });\n     *     } else res.writeHead(501).end();\n     * };\n     *\n     * Whatsapp.on.message = ({ phoneID, from, message, name }) => {\n     *     console.log(`User ${name} (${from}) sent to bot ${phoneID} a(n) ${message.type}`);\n     * };\n     *\n     * const server = createServer(handler);\n     * server.listen(3000);\n     * ```\n     *\n     * @param data - The POSTed data object sent by Whatsapp\n     * @param raw_body - The raw body of the POST request\n     * @param signature - The x-hub-signature-256 (all lowercase) header signature sent by Whatsapp\n     * @returns 200, it's the expected http/s response code\n     * @throws 500 if secure and the appSecret isn't specified\n     * @throws 501 if secure and crypto.subtle or ponyfill isn't available\n     * @throws 400 if secure and the raw body is missing\n     * @throws 401 if secure and the signature is missing\n     * @throws 401 if secure and the signature doesn't match the hash\n     * @throws 400 if the POSTed data is not a valid Whatsapp API request\n     */\n    async post(\n        data: PostData,\n        raw_body?: string,\n        signature?: string\n    ): Promise<200> {\n        //Validating the payload\n        if (this.secure) {\n            if (!this.appSecret) throw 500;\n            if (!this.subtle) throw 501;\n\n            if (!raw_body) throw 400;\n\n            signature = signature?.split(\"sha256=\")[1];\n            if (!signature) throw 401;\n\n            const encoder = new TextEncoder();\n            const keyBuffer = encoder.encode(this.appSecret);\n\n            const key = await this.subtle.importKey(\n                \"raw\",\n                keyBuffer,\n                { name: \"HMAC\", hash: \"SHA-256\" },\n                true,\n                [\"sign\", \"verify\"]\n            );\n\n            const data = encoder.encode(escapeUnicode(raw_body));\n            const result = await this.subtle.sign(\"HMAC\", key, data.buffer);\n            const result_array = Array.from(new Uint8Array(result));\n\n            // Convert an array of bytes to a hex string\n            const check = result_array\n                .map((b) => b.toString(16).padStart(2, \"0\"))\n                .join(\"\");\n\n            if (signature !== check) throw 401;\n        }\n\n        // Throw \"400 Bad Request\" if data is not a valid WhatsApp API request\n        if (!data.object) throw 400;\n\n        const value = data.entry[0].changes[0].value;\n        const phoneID = value.metadata.phone_number_id;\n\n        // Check if the message is a message or a status update\n        if (\"messages\" in value) {\n            const message = value.messages[0];\n\n            const contact = value.contacts?.[0];\n\n            const from = contact?.wa_id ?? message.from;\n            const name = contact?.profile.name;\n\n            const args: OnMessageArgs = {\n                phoneID,\n                from,\n                message,\n                name,\n                raw: data,\n                reply: (response, context = false, biz_opaque_callback_data) =>\n                    this.sendMessage(\n                        phoneID,\n                        from,\n                        response,\n                        context ? message.id : undefined,\n                        biz_opaque_callback_data\n                    ),\n                Whatsapp: this\n            };\n\n            this.user_function(this.on?.message, args);\n        } else if (\"statuses\" in value) {\n            const statuses = value.statuses[0];\n\n            const phone = statuses.recipient_id;\n            const status = statuses.status;\n            const id = statuses.id;\n            const conversation = statuses.conversation;\n            const pricing = statuses.pricing;\n            const error = statuses.errors?.[0];\n            const biz_opaque_callback_data = statuses.biz_opaque_callback_data;\n\n            const args: OnStatusArgs = {\n                phoneID,\n                phone,\n                status,\n                id,\n                conversation,\n                pricing,\n                error,\n                biz_opaque_callback_data,\n                raw: data\n            };\n\n            this.user_function(this.on?.status, args);\n        }\n        // If unknown payload, just ignore it\n        // Facebook doesn't care about your server's opinion\n\n        return 200;\n    }\n\n    /**\n     * GET helper, must be called inside the get function of your code.\n     * Used once at the first webhook setup.\n     *\n     * @example\n     * ```ts\n     * // Simple http example implementation with Whatsapp.get() on Node@^19\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { NodeNext } from \"whatsapp-api-js/setup/node\";\n     *\n     * import { createServer } from \"http\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     * const Whatsapp = new WhatsAppAPI(NodeNext({ token, appSecret }));\n     *\n     * function handler(req, res) {\n     *     if (req.method == \"GET\") {\n     *         const params = new URLSearchParams(req.url.split(\"?\")[1]);\n     *\n     *         const response = Whatsapp.get(Object.fromEntries(params));\n     *\n     *         res.writeHead(200, {\"Content-Type\": \"text/html\"});\n     *         res.write(response)\n     *         res.end();\n     *     } else res.writeHead(501).end();\n     * };\n     *\n     * Whatsapp.on.message = ({ phoneID, from, message, name }) => {\n     *     console.log(`User ${name} (${from}) sent to bot ${phoneID} a(n) ${message.type}`);\n     * };\n     *\n     * const server = createServer(handler);\n     * server.listen(3000);\n     * ```\n     *\n     * @param params - The request object sent by Whatsapp\n     * @returns The challenge string, it must be the http response body\n     * @throws 500 if webhookVerifyToken is not specified\n     * @throws 400 if the request is missing data\n     * @throws 403 if the verification tokens don't match\n     */\n    get(params: GetParams): string {\n        if (!this.webhookVerifyToken) throw 500;\n\n        // Parse params from the webhook verification request\n        const {\n            \"hub.mode\": mode,\n            \"hub.verify_token\": token,\n            \"hub.challenge\": challenge\n        } = params;\n\n        // Check if a token and mode were sent\n        if (!mode || !token) {\n            // Responds with \"400 Bad Request\" if it's missing data\n            throw 400;\n        }\n\n        // Check the mode and token sent are correct\n        if (mode === \"subscribe\" && token === this.webhookVerifyToken) {\n            // Respond with 200 OK and challenge token from the request\n            return challenge;\n        }\n\n        // Responds with \"403 Forbidden\" if verify tokens do not match\n        throw 403;\n    }\n\n    // #endregion\n\n    /**\n     * Make an authenticated request to any url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * @internal\n     * @param url - The url to request to\n     * @returns The fetch response\n     * @throws If url is not specified\n     */\n    _authenicatedRequest(url: string | URL | Request): Promise<Response> {\n        // Keep the check to ensure on runtime that no weird stuff happens\n        if (!url) throw new Error(\"URL must be specified\");\n\n        return this.fetch(url, {\n            headers: {\n                Authorization: `Bearer ${this.token}`\n            }\n        });\n    }\n\n    /**\n     * Get the body of a fetch response\n     *\n     * @internal\n     * @param promise - The fetch response\n     * @returns The json body parsed\n     */\n    private async getBody<T>(\n        promise: Promise<Response>\n    ): Promise<T | Response> {\n        return this.parsed ? ((await (await promise).json()) as T) : promise;\n    }\n\n    /**\n     * Call a user function, offloading it from the main thread if needed\n     *\n     * @internal\n     * @param f - The user function to call\n     * @param a - The arguments to pass to the function\n     */\n    private user_function<A, F extends ((...a: A[]) => unknown) | undefined>(\n        f: F,\n        ...a: A[]\n    ) {\n        if (f) {\n            if (this.offload_functions) {\n                this.offload(f, ...a);\n            } else {\n                f(...a);\n            }\n        }\n    }\n\n    /**\n     * Offload a function to the next tick of the event loop\n     *\n     * @internal\n     * @param f - The function to offload from the main thread\n     * @param a - The arguments to pass to the function\n     */\n    private offload<A, F extends (...a: A[]) => unknown>(f: F, ...a: A[]) {\n        // Thanks @RahulLanjewar93\n        Promise.resolve().then(() => f(...a));\n    }\n}\n"],
  "mappings": "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",
  "names": ["data"]
}
