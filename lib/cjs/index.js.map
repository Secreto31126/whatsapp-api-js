{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["/** @module WhatsAppAPI */\n\nimport type {\n    WhatsAppAPIConstructorArguments,\n    PostData,\n    GetParams,\n    ClientMessage,\n    ClientMessageRequest,\n    ServerMessageResponse,\n    ServerMarkAsReadResponse,\n    ServerCreateQRResponse,\n    ServerRetrieveQRResponse,\n    ServerUpdateQRResponse,\n    ServerDeleteQRResponse,\n    ServerMediaRetrieveResponse,\n    ServerMediaUploadResponse,\n    ServerMediaDeleteResponse\n} from \"./types\";\nimport type {\n    OnMessage,\n    OnMessageArgs,\n    OnSent,\n    OnSentArgs,\n    OnStatus,\n    OnStatusArgs\n} from \"./emitters\";\n\nimport { escapeUnicode } from \"./utils.js\";\nimport { DEFAULT_API_VERSION } from \"./types.js\";\n\n/**\n * The main API Class\n */\nexport class WhatsAppAPI<EmittersReturnType = void> {\n    //#region Properties\n    /**\n     * The API token\n     */\n    private token: string;\n    /**\n     * The app secret\n     */\n    private appSecret?: string;\n    /**\n     * The webhook verify token\n     */\n    private webhookVerifyToken?: string;\n    /**\n     * The API version to use\n     */\n    private v: string;\n    /**\n     * The fetch function for the requests\n     */\n    private fetch: typeof fetch;\n    /**\n     * The CryptoSubtle library for checking the signatures\n     */\n    private subtle?: Pick<typeof crypto.subtle, \"importKey\" | \"sign\">;\n    /**\n     * If true, API operations will return the fetch promise instead. Intended for low level debugging.\n     */\n    private parsed: boolean;\n    /**\n     * If false, the API will be used in a less secure way, removing the need for appSecret. Defaults to true.\n     */\n    private secure: boolean;\n    /**\n     * The callbacks for the events (message, sent, status)\n     *\n     * @example\n     * ```ts\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"my-token\",\n     *     appSecret: \"my-app-secret\"\n     * });\n     *\n     * // Set the callback\n     * Whatsapp.on.message = ({ from, phoneID }) => console.log(`Message from ${from} to bot ${phoneID}`);\n     *\n     * // If you need to disable the callback:\n     * // Whatsapp.on.message = undefined;\n     * ```\n     */\n    public on: {\n        message?: OnMessage<EmittersReturnType>;\n        sent?: OnSent;\n        status?: OnStatus<EmittersReturnType>;\n    } = {};\n    //#endregion\n\n    /**\n     * Main entry point for the API.\n     *\n     * It's highly recommended reading the named parameters docs at\n     * {@link types.TheBasicConstructorArguments},\n     * at least for `token`, `appSecret` and `webhookVerifyToken` properties,\n     * which are the most common in normal usage.\n     *\n     * The other parameters are used for fine tunning the framework,\n     * such as `ponyfill`, which allows the code to execute on platforms\n     * that are missing standard APIs such as fetch and crypto.\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *    token: \"YOUR_TOKEN\",\n     *    appSecret: \"YOUR_APP_SECRET\"\n     * });\n     * ```\n     *\n     * @throws If fetch is not defined in the enviroment and the provided ponyfill isn't a function\n     * @throws If secure is true, crypto.subtle is not defined in the enviroment and the provided ponyfill isn't an object\n     */\n    constructor({\n        token,\n        appSecret,\n        webhookVerifyToken,\n        v,\n        parsed = true,\n        secure = true,\n        ponyfill = {}\n    }: WhatsAppAPIConstructorArguments) {\n        this.token = token;\n        this.secure = !!secure;\n\n        if (this.secure) {\n            this.appSecret = appSecret;\n\n            if (\n                typeof ponyfill.subtle !== \"object\" &&\n                (typeof crypto !== \"object\" ||\n                    typeof crypto?.subtle !== \"object\")\n            ) {\n                throw new Error(\n                    \"subtle is not defined in the enviroment. Consider using a setup helper,\" +\n                        \" defined at 'whatsapp-api-js/setup', or provide a valid ponyfill\" +\n                        \" object with the argument 'ponyfill.subtle'.\"\n                );\n            }\n\n            // Let's hope the user is using a valid ponyfill\n            this.subtle = ponyfill.subtle || crypto.subtle;\n        }\n\n        if (webhookVerifyToken) this.webhookVerifyToken = webhookVerifyToken;\n\n        if (\n            typeof ponyfill.fetch !== \"function\" &&\n            typeof fetch !== \"function\"\n        ) {\n            throw new Error(\n                \"fetch is not defined in the enviroment. Consider using a setup helper,\" +\n                    \" defined at 'whatsapp-api-js/setup', or provide a valid ponyfill\" +\n                    \" object with the argument 'ponyfill.fetch'.\"\n            );\n        }\n\n        // Let's hope the user is using a valid ponyfill\n        this.fetch = ponyfill.fetch || fetch;\n\n        if (v) this.v = v;\n        else {\n            console.warn(\n                `[whatsapp-api-js] Cloud API version not defined. In production, it's strongly recommended pinning it to the desired version with the \"v\" argument. Defaulting to \"${DEFAULT_API_VERSION}\".`\n            );\n            this.v = DEFAULT_API_VERSION;\n        }\n\n        this.parsed = !!parsed;\n    }\n\n    //#region Message Operations\n\n    /**\n     * Send a Whatsapp message\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { Text } from \"whatsapp-api-js/messages/text\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\"\n     * });\n     *\n     * Whatsapp.sendMessage(\n     *     \"BOT_PHONE_ID\",\n     *     \"USER_PHONE\",\n     *     new Text(\"Hello World\")\n     * ).then(console.log);\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param to - The user's phone number\n     * @param message - A Whatsapp message, built using the corresponding module for each type of message.\n     * @param context - The message ID of the message to reply to\n     * @param biz_opaque_callback_data - An arbitrary 512B string, useful for tracking (length not checked by the framework)\n     * @returns The server response\n     */\n    async sendMessage(\n        phoneID: string,\n        to: string,\n        message: ClientMessage,\n        context?: string,\n        biz_opaque_callback_data?: string\n    ): Promise<ServerMessageResponse | Response> {\n        const type = message._type;\n\n        const request = {\n            messaging_product: \"whatsapp\",\n            type,\n            to\n        } as ClientMessageRequest;\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - TS dumb, the _type will always match the type\n        request[type] =\n            // Prettier will probably kill me, but this comment has a purpose.\n            // It prevents ts-ignore from ignoring more than intended.\n            message._build();\n\n        if (context) request.context = { message_id: context };\n        if (biz_opaque_callback_data)\n            request.biz_opaque_callback_data = biz_opaque_callback_data;\n\n        // Make the post request\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(request)\n            }\n        );\n\n        const response = this.parsed\n            ? ((await (await promise).json()) as ServerMessageResponse)\n            : undefined;\n\n        const args: OnSentArgs = {\n            phoneID,\n            to,\n            type,\n            message,\n            request,\n            id: response\n                ? \"messages\" in response\n                    ? response.messages[0].id\n                    : undefined\n                : undefined,\n            held_for_quality_assessment: response\n                ? \"messages\" in response\n                    ? \"message_status\" in response.messages[0]\n                        ? response.messages[0].message_status ===\n                          \"held_for_quality_assessment\"\n                        : undefined\n                    : undefined\n                : undefined,\n            response,\n            offload: WhatsAppAPI.offload,\n            Whatsapp: this\n        };\n\n        try {\n            await this.on?.sent?.(args);\n        } catch (error) {\n            // Eh... I don't like it nor hate it\n            console.error(error);\n        }\n\n        return response ?? promise;\n    }\n\n    /**\n     * Send the same Whatsapp message to multiple phone numbers.\n     *\n     * In order to avoid reaching the\n     * [API rate limit](https://developers.facebook.com/docs/whatsapp/cloud-api/overview?locale=en_US#throughput),\n     * this method will send the messages in batches of 50 per second by default,\n     * but this can be changed using the `batch_size` and `delay` parameters.\n     *\n     * The API rate limit can be increased by contacting Facebook as explained\n     * [here](https://developers.facebook.com/docs/whatsapp/cloud-api/overview?locale=en_US#throughput).\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { Text } from \"whatsapp-api-js/messages/text\";\n     *\n     * const Whatsapp = new WhatsAppAPI({\n     *     token: \"YOUR_TOKEN\",\n     *     appSecret: \"YOUR_APP_SECRET\"\n     * });\n     *\n     * const phoneID = \"YOUR_BOT_NUMBER\";\n     * const users = [\"YOUR_USER1_NUMBER\", \"YOUR_USER2_NUMBER\"];\n     * const message = new Text(\"Hello World\");\n     *\n     * const responses = Whatsapp.broadcastMessage(phoneID, users, message);\n     *\n     * Promise.all(responses).then(console.log);\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param to - The users' phone numbers\n     * @param message - A Whatsapp message, built using the corresponding module for each type of message.\n     * @param batch_size - The number of messages to send per batch\n     * @param delay - The delay between each batch of messages in milliseconds\n     * @returns The server's responses\n     * @throws if batch_size is lower than 1\n     * @throws if delay is lower than 0\n     */\n    broadcastMessage(\n        phoneID: string,\n        to: string[],\n        message: ClientMessage,\n        batch_size = 50,\n        delay = 1000\n    ): Array<ReturnType<WhatsAppAPI[\"sendMessage\"]>> {\n        const responses = [] as ReturnType<WhatsAppAPI[\"sendMessage\"]>[];\n\n        if (batch_size < 1) {\n            throw new RangeError(\"batch_size must be greater than 0\");\n        }\n\n        if (delay < 0) {\n            throw new RangeError(\"delay must be greater or equal to 0\");\n        }\n\n        to.forEach((phone, i) => {\n            responses.push(\n                new Promise((resolve) => {\n                    setTimeout(\n                        () => {\n                            this.sendMessage(phoneID, phone, message).then(\n                                resolve\n                            );\n                        },\n                        delay * ((i / batch_size) | 0)\n                    );\n                })\n            );\n        });\n\n        return responses;\n    }\n\n    /**\n     * Mark a message as read\n     *\n     * @param phoneID - The bot's phone ID\n     * @param messageId - The message ID\n     * @returns The server response\n     */\n    async markAsRead(\n        phoneID: string,\n        messageId: string\n    ): Promise<ServerMarkAsReadResponse | Response> {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/messages`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messaging_product: \"whatsapp\",\n                    status: \"read\",\n                    message_id: messageId\n                })\n            }\n        );\n\n        return this.getBody<ServerMarkAsReadResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region QR Operations\n\n    /**\n     * Generate a QR code for sharing the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param message - The quick message on the QR code\n     * @param format - The format of the QR code\n     * @returns The server response\n     */\n    async createQR(\n        phoneID: string,\n        message: string,\n        format: \"png\" | \"svg\" = \"png\"\n    ): Promise<ServerCreateQRResponse | Response> {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls?generate_qr_image=${format}&prefilled_message=${message}`,\n            {\n                method: \"POST\"\n            }\n        );\n\n        return this.getBody<ServerCreateQRResponse>(promise);\n    }\n\n    /**\n     * Get one or many QR codes of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to find. If not specified, all QRs will be returned\n     * @returns The server response\n     */\n    async retrieveQR(\n        phoneID: string,\n        id?: string\n    ): Promise<ServerRetrieveQRResponse | Response> {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id ?? \"\"}`\n        );\n\n        return this.getBody<ServerRetrieveQRResponse>(promise);\n    }\n\n    /**\n     * Update a QR code of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to edit\n     * @param message - The new quick message for the QR code\n     * @returns The server response\n     */\n    async updateQR(\n        phoneID: string,\n        id: string,\n        message: string\n    ): Promise<ServerUpdateQRResponse | Response> {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}?prefilled_message=${message}`,\n            {\n                method: \"POST\"\n            }\n        );\n\n        return this.getBody<ServerUpdateQRResponse>(promise);\n    }\n\n    /**\n     * Delete a QR code of the bot\n     *\n     * @param phoneID - The bot's phone ID\n     * @param id - The QR's id to delete\n     * @returns The server response\n     */\n    async deleteQR(\n        phoneID: string,\n        id: string\n    ): Promise<ServerDeleteQRResponse | Response> {\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/message_qrdls/${id}`,\n            {\n                method: \"DELETE\"\n            }\n        );\n\n        return this.getBody<ServerDeleteQRResponse>(promise);\n    }\n\n    //#endregion\n\n    //#region Media Operations\n\n    /**\n     * Get a Media object data with an ID\n     *\n     * @see {@link fetchMedia}\n     *\n     * @param id - The Media's ID\n     * @param phoneID - Business phone number ID. If included, the operation will only be processed if the ID matches the ID of the business phone number that the media was uploaded on.\n     * @returns The server response\n     */\n    async retrieveMedia(\n        id: string,\n        phoneID?: string\n    ): Promise<ServerMediaRetrieveResponse | Response> {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`\n        );\n\n        return this.getBody<ServerMediaRetrieveResponse>(promise);\n    }\n\n    /**\n     * Upload a Media to the API server\n     *\n     * @example\n     * ```ts\n     * // author ekoeryanto on issue #322\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * const url = \"https://example.com/image.png\";\n     *\n     * const image = await fetch(url);\n     * const blob = await image.blob();\n     *\n     * // If required:\n     * // import FormData from \"undici\";\n     *\n     * const form = new FormData();\n     * form.set(\"file\", blob);\n     *\n     * console.log(await Whatsapp.uploadMedia(\"phoneID\", form));\n     * // Expected output: { id: \"mediaID\" }\n     * ```\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * // If required:\n     * // import FormData from \"undici\";\n     * // import { Blob } from \"node:buffer\";\n     *\n     * const form = new FormData();\n     *\n     * // If you don't mind reading the whole file into memory:\n     * form.set(\"file\", new Blob([fs.readFileSync(\"image.png\")], \"image/png\"));\n     *\n     * // If you do, you will need to use streams. The module \"form-data\",\n     * // although not spec compliant (hence needing to set check to false),\n     * // has an easy way to do this:\n     * // form.append(\"file\", fs.createReadStream(\"image.png\"), { contentType: \"image/png\" });\n     *\n     * console.log(await Whatsapp.uploadMedia(\"phoneID\", form));\n     * // Expected output: { id: \"mediaID\" }\n     * ```\n     *\n     * @param phoneID - The bot's phone ID\n     * @param form - The Media's FormData. Must have a 'file' property with the file to upload as a blob and a valid mime-type in the 'type' field of the blob. Example for Node ^18: `new FormData().set(\"file\", new Blob([stringOrFileBuffer], \"image/png\"));` Previous versions of Node will need an external FormData, such as undici's. To use non spec complaints versions of FormData (eg: form-data) or Blob set the 'check' parameter to false.\n     * @param check - If the FormData should be checked before uploading. The FormData must have the method .get(\"name\") to work with the checks. If it doesn't (for example, using the module \"form-data\"), set this to false.\n     * @returns The server response\n     * @throws If check is set to true and form is not a FormData\n     * @throws If check is set to true and the form doesn't have valid required properties (file, type)\n     * @throws If check is set to true and the form file is too big for the file type\n     */\n    async uploadMedia(\n        phoneID: string,\n        form: unknown,\n        check = true\n    ): Promise<ServerMediaUploadResponse | Response> {\n        if (check) {\n            if (\n                !form ||\n                typeof form !== \"object\" ||\n                !(\"get\" in form) ||\n                typeof form.get !== \"function\"\n            )\n                throw new TypeError(\n                    \"File's Form must be an instance of FormData\"\n                );\n\n            const file = form.get(\"file\") as Blob;\n\n            if (!file.type)\n                throw new Error(\"File's Blob must have a type specified\");\n\n            const validMediaTypes = [\n                \"audio/aac\",\n                \"audio/mp4\",\n                \"audio/mpeg\",\n                \"audio/amr\",\n                \"audio/ogg\",\n                \"text/plain\",\n                \"application/pdf\",\n                \"application/vnd.ms-powerpoint\",\n                \"application/msword\",\n                \"application/vnd.ms-excel\",\n                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n                \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n                \"image/jpeg\",\n                \"image/png\",\n                \"video/mp4\",\n                \"video/3gp\",\n                \"image/webp\"\n            ];\n\n            if (!validMediaTypes.includes(file.type))\n                throw new Error(`Invalid media type: ${file.type}`);\n\n            const validMediaSizes = {\n                audio: 16_000_000,\n                text: 100_000_000,\n                application: 100_000_000,\n                image: 5_000_000,\n                video: 16_000_000,\n                sticker: 500_000\n            };\n\n            const mediaType =\n                file.type === \"image/webp\"\n                    ? \"sticker\"\n                    : (file.type.split(\"/\")[0] as keyof typeof validMediaSizes);\n\n            if (file.size && file.size > validMediaSizes[mediaType])\n                throw new Error(\n                    `File is too big (${file.size} bytes) for a ${mediaType} (${validMediaSizes[mediaType]} bytes limit)`\n                );\n        }\n\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${phoneID}/media?messaging_product=whatsapp`,\n            {\n                method: \"POST\",\n                body: form as FormData\n            }\n        );\n\n        return this.getBody<ServerMediaUploadResponse>(promise);\n    }\n\n    /**\n     * Get a Media fetch from an url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * @example\n     * ```ts\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     *\n     * const Whatsapp = new WhatsAppAPI({ token, appSecret });\n     *\n     * const id = \"mediaID\";\n     * const { url } = await Whatsapp.retrieveMedia(id);\n     * const response = Whatsapp.fetchMedia(url);\n     * ```\n     *\n     * @param url - The Media's url\n     * @returns The fetch raw response\n     * @throws If url is not a valid url\n     */\n    fetchMedia(url: string): Promise<Response> {\n        /**\n         * Hacky way to check if the url is valid and throw if invalid\n         *\n         * @see https://github.com/Secreto31126/whatsapp-api-js/issues/335#issuecomment-2103814359\n         */\n        return this.$$apiFetch$$(new URL(url), {\n            headers: {\n                // Thanks @tecoad\n                \"User-Agent\":\n                    \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"\n            }\n        });\n    }\n\n    /**\n     * Delete a Media object with an ID\n     *\n     * @param id - The Media's ID\n     * @param phoneID - Business phone number ID. If included, the operation will only be processed if the ID matches the ID of the business phone number that the media was uploaded on.\n     * @returns The server response\n     */\n    async deleteMedia(\n        id: string,\n        phoneID?: string\n    ): Promise<ServerMediaDeleteResponse | Response> {\n        const params = phoneID ? `phone_number_id=${phoneID}` : \"\";\n        const promise = this.$$apiFetch$$(\n            `https://graph.facebook.com/${this.v}/${id}?${params}`,\n            {\n                method: \"DELETE\"\n            }\n        );\n\n        return this.getBody<ServerMediaDeleteResponse>(promise);\n    }\n\n    // #endregion\n\n    // #region Webhooks\n\n    /**\n     * POST helper, must be called inside the post function of your code.\n     * When setting up the webhook, only subscribe to messages. Other subscritions support might be added later.\n     *\n     * @example\n     * ```ts\n     * // author arivanbastos on issue #114\n     * // Simple http example implementation with Whatsapp.post() on Node@^19\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { NodeNext } from \"whatsapp-api-js/setup/node\";\n     *\n     * import { createServer } from \"http\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     * const Whatsapp = new WhatsAppAPI<number>(NodeNext({ token, appSecret }));\n     *\n     * function handler(req, res) {\n     *     if (req.method == \"POST\") {\n     *         const chunks = [];\n     *         req.on(\"data\", (chunk) => chunks.push(chunk));\n     *\n     *         req.on(\"end\", async () => {\n     *             const body = Buffer.concat(chunks).toString();\n     *\n     *             try {\n     *                 const response = await Whatsapp.post(JSON.parse(body), body, req.headers[\"x-hub-signature-256\"]);\n     *                 res.writeHead(response);\n     *             } catch (err) {\n     *                 res.writeHead(err);\n     *             }\n     *\n     *             res.end();\n     *         });\n     *     } else res.writeHead(501).end();\n     * };\n     *\n     * Whatsapp.on.message = ({ phoneID, from, message, name, reply, offload }) => {\n     *     console.log(`User ${name} (${from}) sent to bot ${phoneID} a(n) ${message.type}`);\n     *     offload(() => reply(new Text(\"Hello!\")));\n     *     return 202;\n     * };\n     *\n     * const server = createServer(handler);\n     * server.listen(3000);\n     * ```\n     *\n     * @param data - The POSTed data object sent by Whatsapp\n     * @param raw_body - The raw body of the POST request\n     * @param signature - The x-hub-signature-256 (all lowercase) header signature sent by Whatsapp\n     * @returns The emitter's return value, undefined if the corresponding emitter isn't set\n     * @throws 400 if secure and the raw body is missing\n     * @throws 401 if secure and the signature is missing\n     * @throws 500 if secure and the appSecret isn't defined\n     * @throws 501 if secure and crypto.subtle or ponyfill isn't available\n     * @throws 401 if secure and the signature doesn't match the hash\n     * @throws 400 if the POSTed data is not a valid Whatsapp API request\n     * @throws 500 if the user's callback throws an error\n     * @throws 200, if the POSTed data is valid but not a message or status update (ignored)\n     */\n    async post(\n        data: PostData,\n        raw_body?: string,\n        signature?: string\n    ): Promise<EmittersReturnType | undefined> {\n        //Validating the payload\n        if (this.secure) {\n            if (!raw_body) throw 400;\n            if (!signature) throw 401;\n            if (!(await this.verifyRequestSignature(raw_body, signature))) {\n                throw 401;\n            }\n        }\n\n        // Throw \"400 Bad Request\" if data is not a valid WhatsApp API request\n        if (!data.object) throw 400;\n\n        const value = data.entry[0].changes[0].value;\n        const phoneID = value.metadata.phone_number_id;\n\n        // Check if the message is a message or a status update\n        if (\"messages\" in value) {\n            const message = value.messages[0];\n\n            const contact = value.contacts?.[0];\n\n            const from = contact?.wa_id ?? message.from;\n            const name = contact?.profile.name;\n\n            const args: OnMessageArgs = {\n                phoneID,\n                from,\n                message,\n                name,\n                raw: data,\n                reply: (response, context = false, biz_opaque_callback_data) =>\n                    this.sendMessage(\n                        phoneID,\n                        from,\n                        response,\n                        context ? message.id : undefined,\n                        biz_opaque_callback_data\n                    ),\n                offload: WhatsAppAPI.offload,\n                Whatsapp: this\n            };\n\n            try {\n                return await this.on?.message?.(args);\n            } catch {\n                throw 500;\n            }\n        } else if (\"statuses\" in value) {\n            const statuses = value.statuses[0];\n\n            const phone = statuses.recipient_id;\n            const status = statuses.status;\n            const id = statuses.id;\n            const timestamp = statuses.timestamp;\n            const conversation = statuses.conversation;\n            const pricing = statuses.pricing;\n            const error = statuses.errors?.[0];\n            const biz_opaque_callback_data = statuses.biz_opaque_callback_data;\n\n            const args: OnStatusArgs = {\n                phoneID,\n                phone,\n                status,\n                id,\n                timestamp,\n                conversation,\n                pricing,\n                error,\n                biz_opaque_callback_data,\n                raw: data,\n                offload: WhatsAppAPI.offload,\n                Whatsapp: this\n            };\n\n            try {\n                return await this.on?.status?.(args);\n            } catch {\n                throw 500;\n            }\n        }\n\n        // If unknown payload, just ignore it\n        // Facebook doesn't care about your server's opinion\n        throw 200;\n    }\n\n    /**\n     * GET helper, must be called inside the get function of your code.\n     * Used once at the first webhook setup.\n     *\n     * @example\n     * ```ts\n     * // Simple http example implementation with Whatsapp.get() on Node@^19\n     * import { WhatsAppAPI } from \"whatsapp-api-js\";\n     * import { NodeNext } from \"whatsapp-api-js/setup/node\";\n     *\n     * import { createServer } from \"http\";\n     *\n     * const token = \"token\";\n     * const appSecret = \"appSecret\";\n     * const Whatsapp = new WhatsAppAPI(NodeNext({ token, appSecret }));\n     *\n     * function handler(req, res) {\n     *     if (req.method == \"GET\") {\n     *         const params = new URLSearchParams(req.url.split(\"?\")[1]);\n     *\n     *         const response = Whatsapp.get(Object.fromEntries(params));\n     *\n     *         res.writeHead(200, {\"Content-Type\": \"text/html\"});\n     *         res.write(response)\n     *         res.end();\n     *     } else res.writeHead(501).end();\n     * };\n     *\n     * const server = createServer(handler);\n     * server.listen(3000);\n     * ```\n     *\n     * @param params - The request object sent by Whatsapp\n     * @returns The challenge string, it must be the http response body\n     * @throws 500 if webhookVerifyToken is not specified\n     * @throws 400 if the request is missing data\n     * @throws 403 if the verification tokens don't match\n     */\n    get(params: GetParams): string {\n        if (!this.webhookVerifyToken) throw 500;\n\n        // Parse params from the webhook verification request\n        const {\n            \"hub.mode\": mode,\n            \"hub.verify_token\": token,\n            \"hub.challenge\": challenge\n        } = params;\n\n        // Check if a token and mode were sent\n        if (!mode || !token) {\n            // Responds with \"400 Bad Request\" if it's missing data\n            throw 400;\n        }\n\n        // Check the mode and token sent are correct\n        if (mode === \"subscribe\" && token === this.webhookVerifyToken) {\n            // Respond with 200 OK and challenge token from the request\n            return challenge;\n        }\n\n        // Responds with \"403 Forbidden\" if verify tokens do not match\n        throw 403;\n    }\n\n    // #endregion\n\n    /**\n     * Make an authenticated request to any url.\n     * When using this method, be sure to pass a trusted url, since the request will be authenticated with the token.\n     *\n     * It's strongly recommended NOT using this method as you might risk exposing your API key accidentally,\n     * but it's here in case you need a specific API operation which is not implemented by the library.\n     *\n     * @param url - The url to fetch\n     * @param options - The fetch options (headers.Authorization is already included)\n     * @returns The fetch response\n     */\n    async $$apiFetch$$(\n        url: string | URL | Request,\n        options: RequestInit = {}\n    ): Promise<Response> {\n        return this.fetch(url, {\n            ...options,\n            headers: {\n                Authorization: `Bearer ${this.token}`,\n                ...options.headers\n            }\n        });\n    }\n\n    /**\n     * Verify the signature of a request\n     *\n     * @param raw_body - The raw body of the request\n     * @param signature - The signature to validate\n     * @returns If the signature is valid\n     * @throws 500 if the appSecret isn't defined\n     * @throws 501 if crypto.subtle or ponyfill isn't available\n     */\n    async verifyRequestSignature(\n        raw_body: string,\n        signature: string\n    ): Promise<boolean> {\n        if (!this.appSecret) throw 500;\n        if (!this.subtle) throw 501;\n\n        signature = signature.split(\"sha256=\")[1];\n        if (!signature) return false;\n\n        const encoder = new TextEncoder();\n        const keyBuffer = encoder.encode(this.appSecret);\n\n        const key = await this.subtle.importKey(\n            \"raw\",\n            keyBuffer,\n            { name: \"HMAC\", hash: \"SHA-256\" },\n            true,\n            [\"sign\", \"verify\"]\n        );\n\n        const data = encoder.encode(escapeUnicode(raw_body));\n        const result = await this.subtle.sign(\"HMAC\", key, data.buffer);\n        const result_array = Array.from(new Uint8Array(result));\n\n        // Convert an array of bytes to a hex string\n        const check = result_array\n            .map((b) => b.toString(16).padStart(2, \"0\"))\n            .join(\"\");\n\n        return signature === check;\n    }\n\n    /**\n     * Get the body of a fetch response\n     *\n     * @internal\n     * @param promise - The fetch response\n     * @returns The json body parsed\n     */\n    private async getBody<T>(\n        promise: Promise<Response>\n    ): Promise<T | Response> {\n        return this.parsed ? ((await (await promise).json()) as T) : promise;\n    }\n\n    /**\n     * Offload a function to the next tick of the event loop\n     *\n     * @param f - The function to offload from the main thread\n     */\n    static offload(f: () => unknown) {\n        // Thanks @RahulLanjewar93\n        Promise.resolve().then(f);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
